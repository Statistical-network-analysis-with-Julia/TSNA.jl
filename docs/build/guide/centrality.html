<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Temporal Centrality · TSNA.jl</title><meta name="title" content="Temporal Centrality · TSNA.jl"/><meta property="og:title" content="Temporal Centrality · TSNA.jl"/><meta property="twitter:title" content="Temporal Centrality · TSNA.jl"/><meta name="description" content="Documentation for TSNA.jl."/><meta property="og:description" content="Documentation for TSNA.jl."/><meta property="twitter:description" content="Documentation for TSNA.jl."/><meta property="og:url" content="https://Statistical-network-analysis-with-Julia.github.io/TSNA.jl/guide/centrality.html"/><meta property="twitter:url" content="https://Statistical-network-analysis-with-Julia.github.io/TSNA.jl/guide/centrality.html"/><link rel="canonical" href="https://Statistical-network-analysis-with-Julia.github.io/TSNA.jl/guide/centrality.html"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.svg" alt="TSNA.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">TSNA.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../getting_started.html">Getting Started</a></li><li><span class="tocitem">User Guide</span><ul><li class="is-active"><a class="tocitem" href="centrality.html">Temporal Centrality</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Degree-Centrality"><span>Degree Centrality</span></a></li><li><a class="tocitem" href="#Betweenness-Centrality"><span>Betweenness Centrality</span></a></li><li><a class="tocitem" href="#Closeness-Centrality"><span>Closeness Centrality</span></a></li><li><a class="tocitem" href="#Eigenvector-Centrality"><span>Eigenvector Centrality</span></a></li><li><a class="tocitem" href="#PageRank"><span>PageRank</span></a></li><li><a class="tocitem" href="#Network-Level-Temporal-Measures"><span>Network-Level Temporal Measures</span></a></li><li><a class="tocitem" href="#Computing-Statistics-Over-Time"><span>Computing Statistics Over Time</span></a></li><li><a class="tocitem" href="#Practical-Considerations"><span>Practical Considerations</span></a></li><li><a class="tocitem" href="#Best-Practices"><span>Best Practices</span></a></li></ul></li><li><a class="tocitem" href="paths.html">Temporal Paths</a></li><li><a class="tocitem" href="metrics.html">Duration Metrics</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/centrality.html">Centrality</a></li><li><a class="tocitem" href="../api/paths.html">Paths</a></li><li><a class="tocitem" href="../api/metrics.html">Metrics</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href="centrality.html">Temporal Centrality</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="centrality.html">Temporal Centrality</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Statistical-network-analysis-with-Julia/TSNA.jl/blob/main/docs/src/guide/centrality.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Temporal-Centrality"><a class="docs-heading-anchor" href="#Temporal-Centrality">Temporal Centrality</a><a id="Temporal-Centrality-1"></a><a class="docs-heading-anchor-permalink" href="#Temporal-Centrality" title="Permalink"></a></h1><p>This guide covers the temporal centrality measures available in TSNA.jl. These measures compute standard centrality metrics on network snapshots extracted at specific time points.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Temporal centrality measures answer the question: &quot;Who is most central <strong>at a given time</strong>?&quot; Unlike static centrality, temporal centrality can change as the network evolves – a vertex that is highly central at one time may be peripheral at another.</p><p>All temporal centrality functions in TSNA.jl follow the same pattern:</p><pre><code class="language-julia hljs">centrality_values = tCentrality(dnet, at_time; options...)</code></pre><p>They work by:</p><ol><li>Extracting a static network snapshot at the specified time using <code>network_extract</code></li><li>Computing the standard centrality measure on the snapshot using Graphs.jl algorithms</li><li>Returning a vector of centrality values, one per active vertex</li></ol><h2 id="Degree-Centrality"><a class="docs-heading-anchor" href="#Degree-Centrality">Degree Centrality</a><a id="Degree-Centrality-1"></a><a class="docs-heading-anchor-permalink" href="#Degree-Centrality" title="Permalink"></a></h2><h3 id="tDegree"><a class="docs-heading-anchor" href="#tDegree">tDegree</a><a id="tDegree-1"></a><a class="docs-heading-anchor-permalink" href="#tDegree" title="Permalink"></a></h3><p>Degree centrality counts the number of edges incident to each vertex:</p><pre><code class="language-julia hljs">using NetworkDynamic
using TSNA

# Create dynamic network
dnet = DynamicNetwork(10; observation_start=0.0, observation_end=100.0)
activate_vertices!(dnet, collect(1:10), 0.0, 100.0)
activate!(dnet, 0.0, 50.0; edge=(1, 2))
activate!(dnet, 0.0, 50.0; edge=(1, 3))
activate!(dnet, 0.0, 100.0; edge=(2, 3))
activate!(dnet, 50.0, 100.0; edge=(4, 5))

# Total degree at t=25
deg = tDegree(dnet, 25.0)
println(&quot;Degree at t=25: &quot;, deg)</code></pre><h3 id="Directed-Degree-Modes"><a class="docs-heading-anchor" href="#Directed-Degree-Modes">Directed Degree Modes</a><a id="Directed-Degree-Modes-1"></a><a class="docs-heading-anchor-permalink" href="#Directed-Degree-Modes" title="Permalink"></a></h3><p>For directed networks, specify the degree mode:</p><pre><code class="language-julia hljs"># In-degree (number of incoming edges)
in_deg = tDegree(dnet, 25.0; mode=:in)

# Out-degree (number of outgoing edges)
out_deg = tDegree(dnet, 25.0; mode=:out)

# Total degree (in + out, default)
total_deg = tDegree(dnet, 25.0; mode=:total)</code></pre><table><tr><th style="text-align: right">Mode</th><th style="text-align: right">Counts</th><th style="text-align: right">Interpretation</th></tr><tr><td style="text-align: right"><code>:in</code></td><td style="text-align: right">Incoming edges</td><td style="text-align: right">Popularity, prestige</td></tr><tr><td style="text-align: right"><code>:out</code></td><td style="text-align: right">Outgoing edges</td><td style="text-align: right">Activity, influence</td></tr><tr><td style="text-align: right"><code>:total</code></td><td style="text-align: right">Both directions</td><td style="text-align: right">Overall connectivity</td></tr></table><h3 id="Degree-Over-Time"><a class="docs-heading-anchor" href="#Degree-Over-Time">Degree Over Time</a><a id="Degree-Over-Time-1"></a><a class="docs-heading-anchor-permalink" href="#Degree-Over-Time" title="Permalink"></a></h3><p>Track how a vertex&#39;s degree changes:</p><pre><code class="language-julia hljs">times = collect(0.0:10.0:100.0)
v = 1  # Track vertex 1

println(&quot;Vertex $v degree over time:&quot;)
for t in times
    deg = tDegree(dnet, t)
    if v &lt;= length(deg)
        println(&quot;  t=$t: degree=$(deg[v])&quot;)
    end
end</code></pre><h2 id="Betweenness-Centrality"><a class="docs-heading-anchor" href="#Betweenness-Centrality">Betweenness Centrality</a><a id="Betweenness-Centrality-1"></a><a class="docs-heading-anchor-permalink" href="#Betweenness-Centrality" title="Permalink"></a></h2><h3 id="tBetweenness"><a class="docs-heading-anchor" href="#tBetweenness">tBetweenness</a><a id="tBetweenness-1"></a><a class="docs-heading-anchor-permalink" href="#tBetweenness" title="Permalink"></a></h3><p>Betweenness centrality measures how often a vertex lies on shortest paths between other vertices:</p><pre><code class="language-julia hljs">bet = tBetweenness(dnet, 50.0)
println(&quot;Betweenness at t=50: &quot;, round.(bet, digits=3))

# Unnormalized
bet_raw = tBetweenness(dnet, 50.0; normalized=false)</code></pre><table><tr><th style="text-align: right">Parameter</th><th style="text-align: right">Description</th><th style="text-align: right">Default</th></tr><tr><td style="text-align: right"><code>normalized</code></td><td style="text-align: right">Normalize by <span>$(n-1)(n-2)$</span></td><td style="text-align: right"><code>true</code></td></tr></table><p><strong>Interpretation</strong>: A vertex with high betweenness acts as a bridge or broker between different parts of the network. Temporal betweenness reveals when these brokerage positions exist.</p><h3 id="Temporal-Brokerage-Analysis"><a class="docs-heading-anchor" href="#Temporal-Brokerage-Analysis">Temporal Brokerage Analysis</a><a id="Temporal-Brokerage-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Temporal-Brokerage-Analysis" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Track betweenness over time to find when vertices serve as brokers
times = collect(0.0:5.0:100.0)
n = nv(dnet)

println(&quot;Peak brokerage times:&quot;)
for v in 1:n
    max_bet = 0.0
    max_t = 0.0
    for t in times
        bet = tBetweenness(dnet, t)
        if v &lt;= length(bet) &amp;&amp; bet[v] &gt; max_bet
            max_bet = bet[v]
            max_t = t
        end
    end
    if max_bet &gt; 0
        println(&quot;  Vertex $v: peak betweenness=$(round(max_bet, digits=3)) at t=$max_t&quot;)
    end
end</code></pre><h2 id="Closeness-Centrality"><a class="docs-heading-anchor" href="#Closeness-Centrality">Closeness Centrality</a><a id="Closeness-Centrality-1"></a><a class="docs-heading-anchor-permalink" href="#Closeness-Centrality" title="Permalink"></a></h2><h3 id="tCloseness"><a class="docs-heading-anchor" href="#tCloseness">tCloseness</a><a id="tCloseness-1"></a><a class="docs-heading-anchor-permalink" href="#tCloseness" title="Permalink"></a></h3><p>Closeness centrality measures how close a vertex is to all other vertices (inverse of average shortest path length):</p><pre><code class="language-julia hljs">clo = tCloseness(dnet, 50.0)
println(&quot;Closeness at t=50: &quot;, round.(clo, digits=3))</code></pre><p><strong>Interpretation</strong>: High closeness indicates a vertex can quickly reach (or be reached by) all others. In temporal networks, closeness can change dramatically as edges activate and deactivate.</p><h3 id="Comparing-Centrality-Measures"><a class="docs-heading-anchor" href="#Comparing-Centrality-Measures">Comparing Centrality Measures</a><a id="Comparing-Centrality-Measures-1"></a><a class="docs-heading-anchor-permalink" href="#Comparing-Centrality-Measures" title="Permalink"></a></h3><pre><code class="language-julia hljs">t = 50.0
deg = tDegree(dnet, t)
bet = tBetweenness(dnet, t)
clo = tCloseness(dnet, t)

println(&quot;Vertex\tDegree\tBetween\tCloseness&quot;)
for v in 1:length(deg)
    println(&quot;$v\t$(deg[v])\t$(round(bet[v], digits=3))\t$(round(clo[v], digits=3))&quot;)
end</code></pre><h2 id="Eigenvector-Centrality"><a class="docs-heading-anchor" href="#Eigenvector-Centrality">Eigenvector Centrality</a><a id="Eigenvector-Centrality-1"></a><a class="docs-heading-anchor-permalink" href="#Eigenvector-Centrality" title="Permalink"></a></h2><h3 id="tEigenvector"><a class="docs-heading-anchor" href="#tEigenvector">tEigenvector</a><a id="tEigenvector-1"></a><a class="docs-heading-anchor-permalink" href="#tEigenvector" title="Permalink"></a></h3><p>Eigenvector centrality measures a vertex&#39;s influence based on the influence of its neighbors:</p><pre><code class="language-julia hljs">eig = tEigenvector(dnet, 50.0)
println(&quot;Eigenvector centrality at t=50: &quot;, round.(eig, digits=3))</code></pre><p><strong>Interpretation</strong>: A vertex has high eigenvector centrality when it is connected to other well-connected vertices. This captures &quot;influence&quot; in a recursive sense.</p><p><strong>Note</strong>: Eigenvector centrality may not converge for disconnected networks. If the snapshot at time <span>$t$</span> is disconnected, results should be interpreted with caution.</p><h2 id="PageRank"><a class="docs-heading-anchor" href="#PageRank">PageRank</a><a id="PageRank-1"></a><a class="docs-heading-anchor-permalink" href="#PageRank" title="Permalink"></a></h2><h3 id="tPagerank"><a class="docs-heading-anchor" href="#tPagerank">tPagerank</a><a id="tPagerank-1"></a><a class="docs-heading-anchor-permalink" href="#tPagerank" title="Permalink"></a></h3><p>PageRank is a variant of eigenvector centrality with a damping factor, originally designed for ranking web pages:</p><pre><code class="language-julia hljs">pr = tPagerank(dnet, 50.0)
println(&quot;PageRank at t=50: &quot;, round.(pr, digits=3))

# With custom damping factor
pr_low = tPagerank(dnet, 50.0; damping=0.5)
pr_high = tPagerank(dnet, 50.0; damping=0.95)</code></pre><table><tr><th style="text-align: right">Parameter</th><th style="text-align: right">Description</th><th style="text-align: right">Default</th></tr><tr><td style="text-align: right"><code>damping</code></td><td style="text-align: right">Probability of following an edge (vs. random jump)</td><td style="text-align: right"><code>0.85</code></td></tr></table><p><strong>Interpretation</strong>: PageRank handles disconnected networks better than eigenvector centrality due to the random jump component. Lower damping means more random jumps, leading to more uniform values.</p><h2 id="Network-Level-Temporal-Measures"><a class="docs-heading-anchor" href="#Network-Level-Temporal-Measures">Network-Level Temporal Measures</a><a id="Network-Level-Temporal-Measures-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Level-Temporal-Measures" title="Permalink"></a></h2><h3 id="tDensity"><a class="docs-heading-anchor" href="#tDensity">tDensity</a><a id="tDensity-1"></a><a class="docs-heading-anchor-permalink" href="#tDensity" title="Permalink"></a></h3><p>Network density at a specific time:</p><pre><code class="language-julia hljs">d = tDensity(dnet, 50.0)
println(&quot;Density at t=50: $(round(d, digits=3))&quot;)</code></pre><p>Density equals the number of active edges divided by the maximum possible edges.</p><h3 id="tReciprocity"><a class="docs-heading-anchor" href="#tReciprocity">tReciprocity</a><a id="tReciprocity-1"></a><a class="docs-heading-anchor-permalink" href="#tReciprocity" title="Permalink"></a></h3><p>Proportion of edges that are reciprocated (directed networks):</p><pre><code class="language-julia hljs">r = tReciprocity(dnet, 50.0)
println(&quot;Reciprocity at t=50: $(round(r, digits=3))&quot;)</code></pre><p>For undirected networks, reciprocity is always 1.0.</p><h3 id="tTransitivity"><a class="docs-heading-anchor" href="#tTransitivity">tTransitivity</a><a id="tTransitivity-1"></a><a class="docs-heading-anchor-permalink" href="#tTransitivity" title="Permalink"></a></h3><p>Global clustering coefficient (transitivity):</p><pre><code class="language-julia hljs">tr = tTransitivity(dnet, 50.0)
println(&quot;Transitivity at t=50: $(round(tr, digits=3))&quot;)</code></pre><p>Transitivity measures the proportion of connected triples that form triangles.</p><h2 id="Computing-Statistics-Over-Time"><a class="docs-heading-anchor" href="#Computing-Statistics-Over-Time">Computing Statistics Over Time</a><a id="Computing-Statistics-Over-Time-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Statistics-Over-Time" title="Permalink"></a></h2><h3 id="Point-in-Time-Statistics"><a class="docs-heading-anchor" href="#Point-in-Time-Statistics">Point-in-Time Statistics</a><a id="Point-in-Time-Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Point-in-Time-Statistics" title="Permalink"></a></h3><p>Use <code>tSnaStats</code> to compute multiple statistics at a series of time points:</p><pre><code class="language-julia hljs">times = collect(0.0:10.0:100.0)
stats = tSnaStats(dnet, times;
    stats=[:density, :reciprocity, :transitivity, :n_edges, :n_vertices, :mean_degree]
)

# Access results
densities = stats[:density]
reciprocities = stats[:reciprocity]
edge_counts = stats[:n_edges]

# Print table
println(&quot;Time\tDensity\tRecip\tEdges\tMean Deg&quot;)
for (i, t) in enumerate(times)
    println(&quot;$(t)\t$(round(stats[:density][i], digits=3))\t&quot;,
            &quot;$(round(stats[:reciprocity][i], digits=3))\t&quot;,
            &quot;$(Int(stats[:n_edges][i]))\t&quot;,
            &quot;$(round(stats[:mean_degree][i], digits=2))&quot;)
end</code></pre><h3 id="Available-Statistics"><a class="docs-heading-anchor" href="#Available-Statistics">Available Statistics</a><a id="Available-Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Available-Statistics" title="Permalink"></a></h3><table><tr><th style="text-align: right">Symbol</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>:density</code></td><td style="text-align: right">Network density</td></tr><tr><td style="text-align: right"><code>:reciprocity</code></td><td style="text-align: right">Proportion of reciprocated edges</td></tr><tr><td style="text-align: right"><code>:transitivity</code></td><td style="text-align: right">Global clustering coefficient</td></tr><tr><td style="text-align: right"><code>:n_edges</code></td><td style="text-align: right">Number of active edges</td></tr><tr><td style="text-align: right"><code>:n_vertices</code></td><td style="text-align: right">Number of active vertices</td></tr><tr><td style="text-align: right"><code>:mean_degree</code></td><td style="text-align: right">Mean degree (2 * edges / vertices)</td></tr></table><h3 id="Window-Based-Statistics"><a class="docs-heading-anchor" href="#Window-Based-Statistics">Window-Based Statistics</a><a id="Window-Based-Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Window-Based-Statistics" title="Permalink"></a></h3><p>Use <code>windowSnaStats</code> to compute statistics in sliding windows rather than at point-in-time snapshots:</p><pre><code class="language-julia hljs"># Statistics in 10-unit windows with 5-unit step
stats = windowSnaStats(dnet, 10.0;
    stats=[:density, :n_edges],
    step=5.0
)

println(&quot;Window densities: &quot;, round.(stats[:density], digits=3))
println(&quot;Window edge counts: &quot;, stats[:n_edges])</code></pre><p>The window extraction uses <code>network_extract(dnet, t, t+window_size; rule=:any)</code>, including all elements active at any point during the window.</p><h2 id="Practical-Considerations"><a class="docs-heading-anchor" href="#Practical-Considerations">Practical Considerations</a><a id="Practical-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Practical-Considerations" title="Permalink"></a></h2><h3 id="Empty-Snapshots"><a class="docs-heading-anchor" href="#Empty-Snapshots">Empty Snapshots</a><a id="Empty-Snapshots-1"></a><a class="docs-heading-anchor-permalink" href="#Empty-Snapshots" title="Permalink"></a></h3><p>At some time points, no vertices or edges may be active:</p><pre><code class="language-julia hljs">deg = tDegree(dnet, 200.0)  # After observation period
# May return empty vector or zeros</code></pre><p>Always check that the snapshot has sufficient vertices before computing centrality.</p><h3 id="Vertex-Re-indexing"><a class="docs-heading-anchor" href="#Vertex-Re-indexing">Vertex Re-indexing</a><a id="Vertex-Re-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Vertex-Re-indexing" title="Permalink"></a></h3><p>When extracting snapshots, only active vertices are included and re-indexed. This means vertex IDs in the centrality vector may not correspond to the original vertex IDs:</p><pre><code class="language-julia hljs"># If vertices 3, 5, 7 are active at t=50
# deg[1] corresponds to vertex 3
# deg[2] corresponds to vertex 5
# deg[3] corresponds to vertex 7</code></pre><h3 id="Disconnected-Components"><a class="docs-heading-anchor" href="#Disconnected-Components">Disconnected Components</a><a id="Disconnected-Components-1"></a><a class="docs-heading-anchor-permalink" href="#Disconnected-Components" title="Permalink"></a></h3><p>Some centrality measures (closeness, eigenvector) may behave unexpectedly on disconnected networks. Consider:</p><ul><li>Using PageRank instead of eigenvector centrality for disconnected networks</li><li>Restricting analysis to the largest connected component</li><li>Checking the number of components before computing centrality</li></ul><h2 id="Best-Practices"><a class="docs-heading-anchor" href="#Best-Practices">Best Practices</a><a id="Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Best-Practices" title="Permalink"></a></h2><ol><li><strong>Check snapshot size</strong>: Verify the extracted network has enough vertices for meaningful centrality</li><li><strong>Use appropriate measures</strong>: Degree for local connectivity, betweenness for brokerage, PageRank for global influence</li><li><strong>Track over time</strong>: Compute centrality at multiple time points to reveal dynamics</li><li><strong>Compare measures</strong>: Different centrality measures highlight different aspects of temporal importance</li><li><strong>Consider direction</strong>: Use <code>:in</code> and <code>:out</code> modes for directed networks to distinguish popularity from activity</li><li><strong>Window vs. point</strong>: Use <code>tSnaStats</code> for point-in-time snapshots, <code>windowSnaStats</code> for aggregated views</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started.html">« Getting Started</a><a class="docs-footer-nextpage" href="paths.html">Temporal Paths »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 11 February 2026 21:38">Wednesday 11 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
