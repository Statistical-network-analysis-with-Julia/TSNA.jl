<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Temporal Paths · TSNA.jl</title><meta name="title" content="Temporal Paths · TSNA.jl"/><meta property="og:title" content="Temporal Paths · TSNA.jl"/><meta property="twitter:title" content="Temporal Paths · TSNA.jl"/><meta name="description" content="Documentation for TSNA.jl."/><meta property="og:description" content="Documentation for TSNA.jl."/><meta property="twitter:description" content="Documentation for TSNA.jl."/><meta property="og:url" content="https://Statistical-network-analysis-with-Julia.github.io/TSNA.jl/guide/paths.html"/><meta property="twitter:url" content="https://Statistical-network-analysis-with-Julia.github.io/TSNA.jl/guide/paths.html"/><link rel="canonical" href="https://Statistical-network-analysis-with-Julia.github.io/TSNA.jl/guide/paths.html"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.svg" alt="TSNA.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">TSNA.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../getting_started.html">Getting Started</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="centrality.html">Temporal Centrality</a></li><li class="is-active"><a class="tocitem" href="paths.html">Temporal Paths</a><ul class="internal"><li><a class="tocitem" href="#What-are-Temporal-Paths?"><span>What are Temporal Paths?</span></a></li><li><a class="tocitem" href="#The-tPath-Type"><span>The tPath Type</span></a></li><li><a class="tocitem" href="#Temporal-Distance"><span>Temporal Distance</span></a></li><li><a class="tocitem" href="#Shortest-Temporal-Path"><span>Shortest Temporal Path</span></a></li><li><a class="tocitem" href="#Reachability-Analysis"><span>Reachability Analysis</span></a></li><li><a class="tocitem" href="#Practical-Examples"><span>Practical Examples</span></a></li><li><a class="tocitem" href="#Computational-Complexity"><span>Computational Complexity</span></a></li><li><a class="tocitem" href="#Best-Practices"><span>Best Practices</span></a></li></ul></li><li><a class="tocitem" href="metrics.html">Duration Metrics</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/centrality.html">Centrality</a></li><li><a class="tocitem" href="../api/paths.html">Paths</a></li><li><a class="tocitem" href="../api/metrics.html">Metrics</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href="paths.html">Temporal Paths</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="paths.html">Temporal Paths</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Statistical-network-analysis-with-Julia/TSNA.jl/blob/main/docs/src/guide/paths.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Temporal-Paths"><a class="docs-heading-anchor" href="#Temporal-Paths">Temporal Paths</a><a id="Temporal-Paths-1"></a><a class="docs-heading-anchor-permalink" href="#Temporal-Paths" title="Permalink"></a></h1><p>This guide covers temporal path analysis in TSNA.jl, including time-respecting paths, temporal distance, and reachability analysis.</p><h2 id="What-are-Temporal-Paths?"><a class="docs-heading-anchor" href="#What-are-Temporal-Paths?">What are Temporal Paths?</a><a id="What-are-Temporal-Paths?-1"></a><a class="docs-heading-anchor-permalink" href="#What-are-Temporal-Paths?" title="Permalink"></a></h2><p>In a static network, a path from <span>$A$</span> to <span>$C$</span> through <span>$B$</span> is valid whenever edges <span>$A \to B$</span> and <span>$B \to C$</span> exist. In a temporal network, a path must also respect time – you can only traverse an edge while it is active, and edges must be traversed in non-decreasing time order.</p><pre><code class="language-text hljs">Static:     A → B → C    (always valid if both edges exist)

Temporal:   A --(t=5)--&gt; B --(t=10)--&gt; C    (valid: 5 &lt;= 10)
            A --(t=5)--&gt; B --(t=3)--&gt; C     (INVALID: 3 &lt; 5, going back in time)</code></pre><p>This constraint fundamentally changes reachability. In temporal networks:</p><ul><li>Reachability depends on the <strong>start time</strong></li><li>Reachability is <strong>not symmetric</strong>: A can reach B does not imply B can reach A</li><li>Reachability is <strong>not transitive</strong>: A reaches B and B reaches C does not guarantee A reaches C</li></ul><h2 id="The-tPath-Type"><a class="docs-heading-anchor" href="#The-tPath-Type">The tPath Type</a><a id="The-tPath-Type-1"></a><a class="docs-heading-anchor-permalink" href="#The-tPath-Type" title="Permalink"></a></h2><p>Temporal paths are represented by the <code>tPath{T, Time}</code> type:</p><pre><code class="language-julia hljs">struct tPath{T, Time}
    vertices::Vector{T}       # Sequence of vertices visited
    times::Vector{Time}       # Time at each edge traversal
    edges::Vector{Tuple{T,T}} # Edges traversed
end</code></pre><h3 id="Properties"><a class="docs-heading-anchor" href="#Properties">Properties</a><a id="Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Properties" title="Permalink"></a></h3><ul><li><code>length(path)</code> returns the number of edges (hops)</li><li><code>path.vertices[1]</code> is the source</li><li><code>path.vertices[end]</code> is the target</li><li><code>path.times[i]</code> is the time of the <span>$i$</span>-th edge traversal</li><li><code>path.edges[i]</code> is the <span>$i$</span>-th edge</li></ul><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><pre><code class="language-julia hljs"># A path: 1 --(t=5)--&gt; 2 --(t=10)--&gt; 3 --(t=15)--&gt; 4
path = tPath(
    [1, 2, 3, 4],                    # vertices
    [5.0, 10.0, 15.0],               # times
    [(1, 2), (2, 3), (3, 4)]         # edges
)

println(path)
# tPath: 1 --(5.0)--&gt; 2 --(10.0)--&gt; 3 --(15.0)--&gt; 4

println(&quot;Length: &quot;, length(path))  # 3 edges
println(&quot;Source: &quot;, path.vertices[1])  # 1
println(&quot;Target: &quot;, path.vertices[end])  # 4
println(&quot;Departure: &quot;, path.times[1])  # 5.0
println(&quot;Arrival: &quot;, path.times[end])  # 15.0</code></pre><h2 id="Temporal-Distance"><a class="docs-heading-anchor" href="#Temporal-Distance">Temporal Distance</a><a id="Temporal-Distance-1"></a><a class="docs-heading-anchor-permalink" href="#Temporal-Distance" title="Permalink"></a></h2><h3 id="Finding-Earliest-Arrival"><a class="docs-heading-anchor" href="#Finding-Earliest-Arrival">Finding Earliest Arrival</a><a id="Finding-Earliest-Arrival-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-Earliest-Arrival" title="Permalink"></a></h3><p>The <code>temporalDistance</code> function finds the earliest time at which a target vertex can be reached from a source, starting at a given time:</p><pre><code class="language-julia hljs">using NetworkDynamic
using TSNA

# Create network with sequential edges
dnet = DynamicNetwork(5; observation_start=0.0, observation_end=100.0)
activate_vertices!(dnet, collect(1:5), 0.0, 100.0)

activate!(dnet, 0.0, 20.0; edge=(1, 2))   # Active early
activate!(dnet, 10.0, 40.0; edge=(2, 3))  # Overlaps
activate!(dnet, 30.0, 60.0; edge=(3, 4))  # Later
activate!(dnet, 50.0, 80.0; edge=(4, 5))  # Even later

# Earliest arrival from 1 to 5, starting at t=0
dist = temporalDistance(dnet, 1, 5, 0.0)
println(&quot;Earliest arrival at v5: $dist&quot;)
# Path: 1→2 at t=0, 2→3 at t=10, 3→4 at t=30, 4→5 at t=50
# Arrival: t=50

# Starting later
dist2 = temporalDistance(dnet, 1, 5, 25.0)
println(&quot;Starting at t=25: $dist2&quot;)
# Edge (1,2) is still active at t=25, but we need subsequent edges</code></pre><h3 id="When-No-Path-Exists"><a class="docs-heading-anchor" href="#When-No-Path-Exists">When No Path Exists</a><a id="When-No-Path-Exists-1"></a><a class="docs-heading-anchor-permalink" href="#When-No-Path-Exists" title="Permalink"></a></h3><p>If no temporal path exists, <code>temporalDistance</code> returns <code>Inf</code>:</p><pre><code class="language-julia hljs"># No path exists if we start too late
dist = temporalDistance(dnet, 1, 5, 90.0)
if isinf(dist)
    println(&quot;No temporal path exists starting at t=90&quot;)
end</code></pre><h3 id="Self-Distance"><a class="docs-heading-anchor" href="#Self-Distance">Self-Distance</a><a id="Self-Distance-1"></a><a class="docs-heading-anchor-permalink" href="#Self-Distance" title="Permalink"></a></h3><p>The distance from a vertex to itself is the start time:</p><pre><code class="language-julia hljs">dist = temporalDistance(dnet, 1, 1, 5.0)
println(dist)  # 5.0</code></pre><h2 id="Shortest-Temporal-Path"><a class="docs-heading-anchor" href="#Shortest-Temporal-Path">Shortest Temporal Path</a><a id="Shortest-Temporal-Path-1"></a><a class="docs-heading-anchor-permalink" href="#Shortest-Temporal-Path" title="Permalink"></a></h2><h3 id="Finding-the-Path"><a class="docs-heading-anchor" href="#Finding-the-Path">Finding the Path</a><a id="Finding-the-Path-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-the-Path" title="Permalink"></a></h3><p>The <code>shortestTemporalPath</code> function returns the actual path, not just the arrival time:</p><pre><code class="language-julia hljs">path = shortestTemporalPath(dnet, 1, 5, 0.0)

if !isnothing(path)
    println(&quot;Path found!&quot;)
    println(&quot;Vertices: &quot;, path.vertices)
    println(&quot;Times: &quot;, path.times)
    println(&quot;Edges: &quot;, path.edges)
    println(&quot;Total hops: &quot;, length(path))
else
    println(&quot;No path exists&quot;)
end</code></pre><h3 id="Path-to-Self"><a class="docs-heading-anchor" href="#Path-to-Self">Path to Self</a><a id="Path-to-Self-1"></a><a class="docs-heading-anchor-permalink" href="#Path-to-Self" title="Permalink"></a></h3><pre><code class="language-julia hljs">path = shortestTemporalPath(dnet, 1, 1, 0.0)
println(path)
# tPath: 1  (trivial path, no edges)
println(length(path))  # 0</code></pre><h3 id="Algorithm"><a class="docs-heading-anchor" href="#Algorithm">Algorithm</a><a id="Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm" title="Permalink"></a></h3><p>The shortest temporal path algorithm works as follows:</p><ol><li>Initialize earliest arrival times: <span>$\text{arrival}[s] = t_{\text{start}}$</span>, all others <span>$= \infty$</span></li><li>Sort all edge spells by onset time (ascending)</li><li>For each edge activation <span>$(i, j)$</span> at time <span>$t$</span>:<ul><li>If vertex <span>$i$</span> has been reached by time <span>$t$</span> (i.e., <span>$\text{arrival}[i] \leq t$</span>):<ul><li>If <span>$t &lt; \text{arrival}[j]$</span>: update <span>$\text{arrival}[j] = t$</span> and record predecessor</li></ul></li></ul></li><li>Reconstruct path from predecessor chain</li></ol><p>This is a temporal adaptation of Dijkstra&#39;s algorithm, taking advantage of the fact that edge activations can be processed in time order.</p><h2 id="Reachability-Analysis"><a class="docs-heading-anchor" href="#Reachability-Analysis">Reachability Analysis</a><a id="Reachability-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Reachability-Analysis" title="Permalink"></a></h2><h3 id="Forward-Reachability"><a class="docs-heading-anchor" href="#Forward-Reachability">Forward Reachability</a><a id="Forward-Reachability-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-Reachability" title="Permalink"></a></h3><p>The forward reachable set contains all vertices that can be reached from a source starting at a given time:</p><pre><code class="language-julia hljs"># Who can vertex 1 reach starting at t=0?
reachable = forwardReachableSet(dnet, 1, 0.0)
println(&quot;Forward reachable from v1 at t=0: &quot;, reachable)
println(&quot;Fraction reachable: $(length(reachable))/$(nv(dnet))&quot;)</code></pre><h3 id="Backward-Reachability"><a class="docs-heading-anchor" href="#Backward-Reachability">Backward Reachability</a><a id="Backward-Reachability-1"></a><a class="docs-heading-anchor-permalink" href="#Backward-Reachability" title="Permalink"></a></h3><p>The backward reachable set contains all vertices that can reach a target by a given time:</p><pre><code class="language-julia hljs"># Who can reach vertex 5 by t=100?
sources = backwardReachableSet(dnet, 5, 100.0)
println(&quot;Backward reachable to v5 by t=100: &quot;, sources)</code></pre><h3 id="Reachability-Properties"><a class="docs-heading-anchor" href="#Reachability-Properties">Reachability Properties</a><a id="Reachability-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Reachability-Properties" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Forward reachability always includes the source
reach = forwardReachableSet(dnet, 1, 0.0)
@assert 1 in reach

# Backward reachability always includes the target
sources = backwardReachableSet(dnet, 5, 100.0)
@assert 5 in sources</code></pre><h3 id="Reachability-Over-Time"><a class="docs-heading-anchor" href="#Reachability-Over-Time">Reachability Over Time</a><a id="Reachability-Over-Time-1"></a><a class="docs-heading-anchor-permalink" href="#Reachability-Over-Time" title="Permalink"></a></h3><p>Track how reachability changes with the start time:</p><pre><code class="language-julia hljs">source = 1
println(&quot;Forward reachability from v$source:&quot;)
for t_start in 0.0:10.0:90.0
    reach = forwardReachableSet(dnet, source, t_start)
    println(&quot;  Start at t=$t_start: $(length(reach)) vertices reachable&quot;)
end</code></pre><p>As the start time increases, fewer future edge activations are available, so reachability typically decreases.</p><h2 id="Practical-Examples"><a class="docs-heading-anchor" href="#Practical-Examples">Practical Examples</a><a id="Practical-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Practical-Examples" title="Permalink"></a></h2><h3 id="Information-Spread-Analysis"><a class="docs-heading-anchor" href="#Information-Spread-Analysis">Information Spread Analysis</a><a id="Information-Spread-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Information-Spread-Analysis" title="Permalink"></a></h3><p>Analyze how quickly information can spread through a network:</p><pre><code class="language-julia hljs">dnet = DynamicNetwork(20; observation_start=0.0, observation_end=100.0)
activate_vertices!(dnet, collect(1:20), 0.0, 100.0)

# Add edges (communication events)
# ... (add many edges with various activity spells)

# How many vertices can be reached from vertex 1 at different times?
source = 1
println(&quot;Information spread from vertex $source:&quot;)
for t in 0.0:10.0:100.0
    reach = forwardReachableSet(dnet, source, t)
    println(&quot;  Starting at t=$t: $(length(reach)) vertices reachable&quot;)
end

# What fraction of all pairs are temporally connected?
n = nv(dnet)
connected_pairs = 0
total_pairs = n * (n - 1)

for s in 1:n
    reach = forwardReachableSet(dnet, s, 0.0)
    connected_pairs += length(reach) - 1  # Exclude self
end

println(&quot;Temporal connectivity: $(connected_pairs)/$(total_pairs) = &quot;,
        &quot;$(round(connected_pairs/total_pairs, digits=3))&quot;)</code></pre><h3 id="Earliest-Delivery-Analysis"><a class="docs-heading-anchor" href="#Earliest-Delivery-Analysis">Earliest Delivery Analysis</a><a id="Earliest-Delivery-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Earliest-Delivery-Analysis" title="Permalink"></a></h3><p>Find the earliest time each vertex can receive information from a source:</p><pre><code class="language-julia hljs">source = 1
start_time = 0.0

println(&quot;Earliest arrival from vertex $source:&quot;)
for target in 1:nv(dnet)
    target == source &amp;&amp; continue
    dist = temporalDistance(dnet, source, target, start_time)
    if isinf(dist)
        println(&quot;  v$target: unreachable&quot;)
    else
        println(&quot;  v$target: arrives at t=$dist&quot;)
    end
end</code></pre><h3 id="Path-Analysis"><a class="docs-heading-anchor" href="#Path-Analysis">Path Analysis</a><a id="Path-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Path-Analysis" title="Permalink"></a></h3><p>Compare paths from different starting times:</p><pre><code class="language-julia hljs">source = 1
target = 10

println(&quot;Paths from v$source to v$target:&quot;)
for t_start in 0.0:20.0:80.0
    path = shortestTemporalPath(dnet, source, target, t_start)
    if !isnothing(path)
        println(&quot;  Start t=$t_start: $(length(path)) hops, &quot;,
                &quot;arrival at t=$(path.times[end])&quot;)
    else
        println(&quot;  Start t=$t_start: no path&quot;)
    end
end</code></pre><h3 id="Bidirectional-Reachability"><a class="docs-heading-anchor" href="#Bidirectional-Reachability">Bidirectional Reachability</a><a id="Bidirectional-Reachability-1"></a><a class="docs-heading-anchor-permalink" href="#Bidirectional-Reachability" title="Permalink"></a></h3><p>Find vertices that can both reach and be reached by a focal vertex:</p><pre><code class="language-julia hljs">focal = 1

# Forward: who can focal reach?
forward = forwardReachableSet(dnet, focal, 0.0)

# Backward: who can reach focal?
backward = backwardReachableSet(dnet, focal, 100.0)

# Bidirectional: both forward and backward reachable
bidirectional = intersect(forward, backward)

println(&quot;Forward reachable: $(length(forward))&quot;)
println(&quot;Backward reachable: $(length(backward))&quot;)
println(&quot;Bidirectional: $(length(bidirectional))&quot;)</code></pre><h2 id="Computational-Complexity"><a class="docs-heading-anchor" href="#Computational-Complexity">Computational Complexity</a><a id="Computational-Complexity-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-Complexity" title="Permalink"></a></h2><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Complexity</th><th style="text-align: right">Notes</th></tr><tr><td style="text-align: right"><code>temporalDistance</code></td><td style="text-align: right"><span>$O(E \log E)$</span></td><td style="text-align: right"><span>$E$</span> = total edge spells</td></tr><tr><td style="text-align: right"><code>shortestTemporalPath</code></td><td style="text-align: right"><span>$O(E \log E + P)$</span></td><td style="text-align: right"><span>$P$</span> = path reconstruction</td></tr><tr><td style="text-align: right"><code>forwardReachableSet</code></td><td style="text-align: right"><span>$O(E \log E)$</span></td><td style="text-align: right">Same as temporalDistance</td></tr><tr><td style="text-align: right"><code>backwardReachableSet</code></td><td style="text-align: right"><span>$O(E \log E)$</span></td><td style="text-align: right">Reverse time processing</td></tr></table><p>All algorithms sort edge spells by onset time, then process them in order. The dominant cost is the sort, making them efficient for networks with many vertices but moderate numbers of edge spells.</p><h2 id="Best-Practices"><a class="docs-heading-anchor" href="#Best-Practices">Best Practices</a><a id="Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Best-Practices" title="Permalink"></a></h2><ol><li><strong>Choose appropriate start times</strong>: Reachability depends strongly on the start time</li><li><strong>Consider direction</strong>: In directed networks, forward and backward reachability differ</li><li><strong>Check for Inf</strong>: Always check if <code>temporalDistance</code> returns <code>Inf</code> before using the result</li><li><strong>Use forward reachability for spread</strong>: Forward reachable sets model information or disease spread</li><li><strong>Use backward reachability for influence</strong>: Backward reachable sets identify potential sources of influence</li><li><strong>Track over time</strong>: Compute reachability at multiple start times to understand dynamics</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="centrality.html">« Temporal Centrality</a><a class="docs-footer-nextpage" href="metrics.html">Duration Metrics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 11 February 2026 21:38">Wednesday 11 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
