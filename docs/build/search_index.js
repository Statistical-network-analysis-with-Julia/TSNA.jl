var documenterSearchIndex = {"docs":
[{"location":"api/paths.html#Paths-API-Reference","page":"Paths","title":"Paths API Reference","text":"This page documents the temporal path and reachability functions in TSNA.jl.","category":"section"},{"location":"api/paths.html#Path-Types","page":"Paths","title":"Path Types","text":"","category":"section"},{"location":"api/paths.html#Temporal-Distance-and-Path-Finding","page":"Paths","title":"Temporal Distance and Path Finding","text":"","category":"section"},{"location":"api/paths.html#Reachability","page":"Paths","title":"Reachability","text":"","category":"section"},{"location":"api/paths.html#Contact-Sequence-Conversion","page":"Paths","title":"Contact Sequence Conversion","text":"","category":"section"},{"location":"api/paths.html#TSNA.tPath","page":"Paths","title":"TSNA.tPath","text":"tPath{T, Time}\n\nA temporal path through a dynamic network.\n\nA valid temporal path must have non-decreasing times along the path.\n\nFields\n\nvertices::Vector{T}: Sequence of vertices\ntimes::Vector{Time}: Times at which each transition occurs\nedges::Vector{Tuple{T, T}}: Edges traversed\n\n\n\n\n\n","category":"type"},{"location":"api/paths.html#TSNA.Contact","page":"Paths","title":"TSNA.Contact","text":"Contact{T, Time}\n\nA single contact (edge activation) in a temporal network.\n\n\n\n\n\n","category":"type"},{"location":"api/paths.html#TSNA.ContactSequence","page":"Paths","title":"TSNA.ContactSequence","text":"ContactSequence{T, Time}\n\nA sequence of contacts ordered by time.\n\n\n\n\n\n","category":"type"},{"location":"api/paths.html#TSNA.temporalDistance","page":"Paths","title":"TSNA.temporalDistance","text":"temporalDistance(dnet::DynamicNetwork, source, target, start_time; kwargs...) -> Time\n\nFind the earliest arrival time from source to target starting at start_time. Returns Inf if no path exists.\n\n\n\n\n\n","category":"function"},{"location":"api/paths.html#TSNA.shortestTemporalPath","page":"Paths","title":"TSNA.shortestTemporalPath","text":"shortestTemporalPath(dnet::DynamicNetwork, source, target, start_time) -> Union{tPath, Nothing}\n\nFind a shortest temporal path from source to target.\n\n\n\n\n\n","category":"function"},{"location":"api/paths.html#TSNA.forwardReachableSet","page":"Paths","title":"TSNA.forwardReachableSet","text":"forwardReachableSet(dnet::DynamicNetwork, source, start_time) -> Set{T}\n\nFind all vertices reachable from source starting at start_time.\n\n\n\n\n\n","category":"function"},{"location":"api/paths.html#TSNA.backwardReachableSet","page":"Paths","title":"TSNA.backwardReachableSet","text":"backwardReachableSet(dnet::DynamicNetwork, target, end_time) -> Set{T}\n\nFind all vertices that can reach target by end_time.\n\n\n\n\n\n","category":"function"},{"location":"api/paths.html#TSNA.as_contact_sequence","page":"Paths","title":"TSNA.as_contact_sequence","text":"as_contact_sequence(dnet::DynamicNetwork) -> ContactSequence\n\nConvert a dynamic network to a contact sequence.\n\n\n\n\n\n","category":"function"},{"location":"guide/metrics.html#Duration-Metrics","page":"Duration Metrics","title":"Duration Metrics","text":"This guide covers the duration, persistence, turnover, and aggregation metrics available in TSNA.jl for characterizing network dynamics.","category":"section"},{"location":"guide/metrics.html#Overview","page":"Duration Metrics","title":"Overview","text":"While centrality and path analysis describe the network at specific times, duration metrics characterize how the network changes over time. They answer questions like:\n\nHow long do ties last?\nHow stable is the network structure?\nAt what rate are new ties forming and old ties dissolving?\nIs the network becoming denser or sparser over time?","category":"section"},{"location":"guide/metrics.html#Edge-Duration","page":"Duration Metrics","title":"Edge Duration","text":"","category":"section"},{"location":"guide/metrics.html#tEdgeDuration","page":"Duration Metrics","title":"tEdgeDuration","text":"Compute the total duration of edge activity:\n\nusing NetworkDynamic\nusing TSNA\n\ndnet = DynamicNetwork(5; observation_start=0.0, observation_end=100.0)\nactivate_vertices!(dnet, collect(1:5), 0.0, 100.0)\n\nactivate!(dnet, 0.0, 50.0; edge=(1, 2))    # Duration: 50\nactivate!(dnet, 10.0, 30.0; edge=(2, 3))   # Duration: 20\nactivate!(dnet, 40.0, 80.0; edge=(3, 4))   # Duration: 40\nactivate!(dnet, 0.0, 100.0; edge=(4, 5))   # Duration: 100\nactivate!(dnet, 20.0, 40.0; edge=(1, 3))   # Duration: 20\n\n# Mean edge duration\nmean_dur = tEdgeDuration(dnet; aggregate=:mean)\nprintln(\"Mean edge duration: $mean_dur\")  # (50+20+40+100+20)/5 = 46.0\n\n# Median edge duration\nmed_dur = tEdgeDuration(dnet; aggregate=:median)\nprintln(\"Median edge duration: $med_dur\")  # 40.0\n\n# Total edge-time\ntotal_dur = tEdgeDuration(dnet; aggregate=:total)\nprintln(\"Total edge-time: $total_dur\")  # 230.0\n\n# Per-edge durations\nall_durs = tEdgeDuration(dnet; aggregate=:all)\nfor (edge, dur) in all_durs\n    println(\"  Edge $(edge[1])->$(edge[2]): $dur\")\nend","category":"section"},{"location":"guide/metrics.html#Aggregation-Options","page":"Duration Metrics","title":"Aggregation Options","text":"Option Description\n:mean Mean duration across all edges\n:median Median duration\n:total Sum of all durations\n:all Dictionary mapping each edge to its duration","category":"section"},{"location":"guide/metrics.html#Multiple-Spells","page":"Duration Metrics","title":"Multiple Spells","text":"When an edge has multiple activity spells, tEdgeDuration sums them:\n\n# Edge (1,2) active in two periods\nactivate!(dnet, 0.0, 20.0; edge=(1, 2))\nactivate!(dnet, 40.0, 60.0; edge=(1, 2))\n\n# Duration = 20 + 20 = 40\ndur = tEdgeDuration(dnet; aggregate=:all)\nprintln(\"Edge (1,2) total duration: \", dur[(1, 2)])  # 40.0","category":"section"},{"location":"guide/metrics.html#Vertex-Duration","page":"Duration Metrics","title":"Vertex Duration","text":"","category":"section"},{"location":"guide/metrics.html#tVertexDuration","page":"Duration Metrics","title":"tVertexDuration","text":"Compute the total duration of vertex activity:\n\n# Mean vertex activity duration\nv_dur = tVertexDuration(dnet; aggregate=:mean)\nprintln(\"Mean vertex duration: $v_dur\")\n\n# All vertex durations\nall_v_dur = tVertexDuration(dnet; aggregate=:all)\nfor (i, dur) in enumerate(all_v_dur)\n    println(\"  Vertex $i: $dur\")\nend\n\nThe same aggregation options (:mean, :median, :total, :all) apply.","category":"section"},{"location":"guide/metrics.html#Edge-Persistence","page":"Duration Metrics","title":"Edge Persistence","text":"","category":"section"},{"location":"guide/metrics.html#tEdgePersistence","page":"Duration Metrics","title":"tEdgePersistence","text":"Measures the proportion of edges that persist (survive) across time windows:\n\n# Edge persistence across 20-unit windows\npersistence = tEdgePersistence(dnet, 20.0)\nprintln(\"Persistence (window=20): $(round(persistence, digits=3))\")\n\nHow it works:\n\nDivide the observation period into windows of the specified size\nFor each consecutive pair of windows (w_i w_i+1):\nCount edges active at the start of w_i\nCount how many are also active at the start of w_i+1\nReturn the overall proportion: persisted / total","category":"section"},{"location":"guide/metrics.html#Interpreting-Persistence","page":"Duration Metrics","title":"Interpreting Persistence","text":"Persistence Interpretation\n~1.0 Very stable network (almost no edge turnover)\n~0.5 Moderate turnover (half of edges change per window)\n~0.0 High turnover (almost complete edge replacement)","category":"section"},{"location":"guide/metrics.html#Window-Size-Sensitivity","page":"Duration Metrics","title":"Window Size Sensitivity","text":"# Persistence at different window sizes\nfor w in [5.0, 10.0, 20.0, 30.0, 50.0]\n    p = tEdgePersistence(dnet, w)\n    println(\"Window=$w: persistence=$(round(p, digits=3))\")\nend\n\nLarger windows allow more time for changes, so persistence generally decreases with window size.","category":"section"},{"location":"guide/metrics.html#Turnover","page":"Duration Metrics","title":"Turnover","text":"","category":"section"},{"location":"guide/metrics.html#tTurnover","page":"Duration Metrics","title":"tTurnover","text":"Compute edge formation and dissolution rates:\n\nturnover = tTurnover(dnet, 20.0)\n\nprintln(\"Formation rate: $(round(turnover.formation_rate, digits=4))\")\nprintln(\"Dissolution rate: $(round(turnover.dissolution_rate, digits=4))\")\nprintln(\"Number of formations: $(turnover.n_formations)\")\nprintln(\"Number of dissolutions: $(turnover.n_dissolutions)\")","category":"section"},{"location":"guide/metrics.html#Returned-Fields","page":"Duration Metrics","title":"Returned Fields","text":"Field Description\nformation_rate Formations / at-risk non-edges\ndissolution_rate Dissolutions / at-risk edges\nn_formations Total number of new edges across all windows\nn_dissolutions Total number of dissolved edges across all windows","category":"section"},{"location":"guide/metrics.html#Understanding-Rates","page":"Duration Metrics","title":"Understanding Rates","text":"The formation rate is the probability that a non-edge becomes an edge in the next window:\n\ntextformation rate = fractextnew edges at  t+1textnon-edges at  t\n\nThe dissolution rate is the probability that an edge dissolves in the next window:\n\ntextdissolution rate = fractextdissolved edges at  t+1textedges at  t","category":"section"},{"location":"guide/metrics.html#Turnover-Analysis","page":"Duration Metrics","title":"Turnover Analysis","text":"# Compare turnover at different timescales\nfor w in [10.0, 20.0, 30.0]\n    t = tTurnover(dnet, w)\n    println(\"Window $w:\")\n    println(\"  Formation: $(round(t.formation_rate, digits=4)) ($(t.n_formations) new)\")\n    println(\"  Dissolution: $(round(t.dissolution_rate, digits=4)) ($(t.n_dissolutions) lost)\")\n    println(\"  Net change: $(t.n_formations - t.n_dissolutions)\")\nend","category":"section"},{"location":"guide/metrics.html#Tie-Decay","page":"Duration Metrics","title":"Tie Decay","text":"","category":"section"},{"location":"guide/metrics.html#tieDecay","page":"Duration Metrics","title":"tieDecay","text":"Estimate the rate at which ties decay (end) from observed edge spell durations:\n\n# Exponential decay rate (MLE for exponential distribution)\ndecay = tieDecay(dnet; method=:exponential)\nprintln(\"Decay rate: $(round(decay, digits=4))\")\nprintln(\"Expected duration: $(round(1.0/decay, digits=1))\")\n\n# Halflife method\nhalflife_rate = tieDecay(dnet; method=:halflife)\nprintln(\"Halflife decay rate: $(round(halflife_rate, digits=4))\")\nprintln(\"Halflife: $(round(log(2)/halflife_rate, digits=1))\")","category":"section"},{"location":"guide/metrics.html#Methods","page":"Duration Metrics","title":"Methods","text":"Method Formula Interpretation\n:exponential hatlambda = 1bard Rate parameter of exponential distribution\n:halflife hatlambda_h = ln(2)bard Rate such that P(textsurvive   texthalflife) = 05\n\nWhere bard is the mean edge duration.","category":"section"},{"location":"guide/metrics.html#Contact-Sequences","page":"Duration Metrics","title":"Contact Sequences","text":"","category":"section"},{"location":"guide/metrics.html#as*contact*sequence","page":"Duration Metrics","title":"ascontactsequence","text":"Convert a dynamic network to a flat sequence of contacts:\n\ncs = as_contact_sequence(dnet)\nprintln(\"Number of contacts: $(length(cs))\")\n\nfor contact in cs\n    println(\"  $(contact.source) -> $(contact.target): \",\n            \"start=$(contact.time), duration=$(contact.duration)\")\nend","category":"section"},{"location":"guide/metrics.html#The-Contact-Type","page":"Duration Metrics","title":"The Contact Type","text":"struct Contact{T, Time}\n    source::T       # Source vertex\n    target::T       # Target vertex\n    time::Time      # Start time\n    duration::Time  # Duration of contact\nend","category":"section"},{"location":"guide/metrics.html#The-ContactSequence-Type","page":"Duration Metrics","title":"The ContactSequence Type","text":"struct ContactSequence{T, Time}\n    contacts::Vector{Contact{T, Time}}  # Sorted by time\n    n_vertices::Int                     # Number of vertices\n    directed::Bool                      # Whether directed\nend\n\nContact sequences are sorted by time and support iteration:\n\ncs = as_contact_sequence(dnet)\n\n# Iterate over contacts\nfor c in cs\n    println(\"$(c.source) -> $(c.target) at t=$(c.time)\")\nend","category":"section"},{"location":"guide/metrics.html#Network-Aggregation","page":"Duration Metrics","title":"Network Aggregation","text":"","category":"section"},{"location":"guide/metrics.html#tAggregate","page":"Duration Metrics","title":"tAggregate","text":"Collapse a dynamic network to a static network:\n\n# Union: include any edge that was ever active\nstatic_union = tAggregate(dnet; method=:union)\nprintln(\"Union: $(ne(static_union)) edges\")\n\n# Intersection: include edges active throughout the entire observation period\nstatic_inter = tAggregate(dnet; method=:intersection)\nprintln(\"Intersection: $(ne(static_inter)) edges\")\n\n# Weighted: weight by total activation time\nstatic_weighted = tAggregate(dnet; method=:weighted)\nprintln(\"Weighted: $(ne(static_weighted)) edges\")","category":"section"},{"location":"guide/metrics.html#Aggregation-Methods","page":"Duration Metrics","title":"Aggregation Methods","text":"Method Include Edge If Weight\n:union Edge was ever active 1.0\n:intersection Edge active throughout entire observation period 1.0\n:weighted Edge was ever active Total activation time","category":"section"},{"location":"guide/metrics.html#Weighted-Aggregation","page":"Duration Metrics","title":"Weighted Aggregation","text":"The weighted method creates a static network where edge weights represent total activity time:\n\nstatic = tAggregate(dnet; method=:weighted)\n\n# Access edge weights\nfor e in edges(static)\n    w = get_edge_attribute(static, src(e), dst(e), :weight)\n    println(\"Edge $(src(e))->$(dst(e)): weight = $w\")\nend","category":"section"},{"location":"guide/metrics.html#Time-Series-Analysis","page":"Duration Metrics","title":"Time Series Analysis","text":"","category":"section"},{"location":"guide/metrics.html#Regular-Interval-Statistics","page":"Duration Metrics","title":"Regular Interval Statistics","text":"Use tSnaStats to compute SNA statistics at regular time points:\n\ntimes = collect(0.0:5.0:100.0)\nstats = tSnaStats(dnet, times;\n    stats=[:density, :reciprocity, :n_edges, :mean_degree]\n)\n\n# Plot-ready data\nfor (i, t) in enumerate(times)\n    println(\"t=$t: density=$(round(stats[:density][i], digits=3)), \",\n            \"edges=$(Int(stats[:n_edges][i]))\")\nend","category":"section"},{"location":"guide/metrics.html#Sliding-Window-Statistics","page":"Duration Metrics","title":"Sliding Window Statistics","text":"Use windowSnaStats to compute statistics in sliding windows:\n\nstats = windowSnaStats(dnet, 20.0;\n    stats=[:density, :n_edges],\n    step=10.0  # 50% overlap\n)\n\nprintln(\"Window densities: \", round.(stats[:density], digits=3))","category":"section"},{"location":"guide/metrics.html#Comparing-Point-in-Time-vs.-Window","page":"Duration Metrics","title":"Comparing Point-in-Time vs. Window","text":"times = collect(0.0:10.0:100.0)\n\n# Point-in-time: what is the density at each instant?\npoint_stats = tSnaStats(dnet, times; stats=[:density])\n\n# Window: what is the density aggregated over each 10-unit window?\nwindow_stats = windowSnaStats(dnet, 10.0; stats=[:density])\n\nprintln(\"Point densities: \", round.(point_stats[:density], digits=3))\nprintln(\"Window densities: \", round.(window_stats[:density], digits=3))\n\nPoint-in-time measures capture the instantaneous state. Window measures capture aggregate activity over a period and are typically higher (more edges are active at some point during the window than at any single instant).","category":"section"},{"location":"guide/metrics.html#Complete-Dynamics-Example","page":"Duration Metrics","title":"Complete Dynamics Example","text":"using NetworkDynamic\nusing TSNA\n\n# Create a network with known dynamics\nn = 15\ndnet = DynamicNetwork(n; observation_start=0.0, observation_end=100.0)\nactivate_vertices!(dnet, collect(1:n), 0.0, 100.0)\n\n# Phase 1 (0-30): Initial connections form\nfor i in 1:5\n    activate!(dnet, 0.0, 40.0; edge=(i, i+1))\nend\n\n# Phase 2 (20-60): Network densifies\nfor i in 1:10\n    activate!(dnet, 20.0, 60.0; edge=(i, mod1(i+2, n)))\nend\n\n# Phase 3 (50-100): Some ties persist, others dissolve\nfor i in 1:8\n    activate!(dnet, 50.0, 100.0; edge=(i, mod1(i+3, n)))\nend\n\n# === Full Dynamics Analysis ===\n\nprintln(\"=== Edge Duration ===\")\ndur = tEdgeDuration(dnet; aggregate=:mean)\nprintln(\"Mean edge duration: $(round(dur, digits=1))\")\n\nprintln(\"\\n=== Persistence ===\")\nfor w in [10.0, 20.0, 30.0]\n    p = tEdgePersistence(dnet, w)\n    println(\"Window $w: $(round(p, digits=3))\")\nend\n\nprintln(\"\\n=== Turnover ===\")\nt = tTurnover(dnet, 20.0)\nprintln(\"Formation rate: $(round(t.formation_rate, digits=4))\")\nprintln(\"Dissolution rate: $(round(t.dissolution_rate, digits=4))\")\n\nprintln(\"\\n=== Tie Decay ===\")\ndecay = tieDecay(dnet; method=:exponential)\nprintln(\"Decay rate: $(round(decay, digits=4))\")\nprintln(\"Expected tie lifetime: $(round(1/decay, digits=1))\")\n\nprintln(\"\\n=== Network Evolution ===\")\ntimes = collect(0.0:10.0:100.0)\nstats = tSnaStats(dnet, times; stats=[:density, :n_edges])\nfor (i, t) in enumerate(times)\n    println(\"t=$t: $(Int(stats[:n_edges][i])) edges, \",\n            \"density=$(round(stats[:density][i], digits=3))\")\nend","category":"section"},{"location":"guide/metrics.html#Best-Practices","page":"Duration Metrics","title":"Best Practices","text":"Choose appropriate window sizes: Window sizes should match the timescale of interest in your research question\nReport multiple metrics: Use persistence, turnover, and duration together for a complete picture\nConsider censoring: Edge spells at the boundaries of the observation period may be censored (truncated)\nUse aggregation wisely: Union is most inclusive, intersection most conservative, weighted preserves duration information\nCheck for empty windows: Some time windows may have no edges, producing division-by-zero or empty results\nCompare with expectations: Null models or benchmark values help interpret whether observed turnover is high or low","category":"section"},{"location":"getting_started.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This tutorial walks through common use cases for TSNA.jl, from computing temporal centrality to analyzing reachability and network dynamics.","category":"section"},{"location":"getting_started.html#Installation","page":"Getting Started","title":"Installation","text":"Install TSNA.jl from GitHub:\n\nusing Pkg\nPkg.add(url=\"https://github.com/Statistical-network-analysis-with-Julia/TSNA.jl\")\n\nTSNA.jl depends on NetworkDynamic.jl, Network.jl, and SNA.jl, which will be installed automatically.","category":"section"},{"location":"getting_started.html#Basic-Workflow","page":"Getting Started","title":"Basic Workflow","text":"The typical TSNA.jl workflow consists of four steps:\n\nCreate or load a dynamic network - Using NetworkDynamic.jl\nCompute temporal measures - Centrality, density, and other metrics at specific times\nAnalyze temporal paths - Find reachable sets and shortest paths\nCompute duration metrics - Edge persistence, turnover, and decay rates","category":"section"},{"location":"getting_started.html#Step-1:-Create-a-Dynamic-Network","page":"Getting Started","title":"Step 1: Create a Dynamic Network","text":"TSNA.jl operates on DynamicNetwork objects from NetworkDynamic.jl:\n\nusing NetworkDynamic\nusing TSNA\n\n# Create a dynamic network with 10 vertices\ndnet = DynamicNetwork(10;\n    observation_start=0.0,\n    observation_end=100.0\n)\n\n# Activate all vertices for the entire period\nactivate_vertices!(dnet, collect(1:10), 0.0, 100.0)\n\n# Add edges with different activity periods\nactivate!(dnet, 0.0, 40.0; edge=(1, 2))    # Active early\nactivate!(dnet, 10.0, 60.0; edge=(2, 3))   # Overlaps with (1,2)\nactivate!(dnet, 30.0, 80.0; edge=(3, 4))   # Overlaps with (2,3)\nactivate!(dnet, 50.0, 100.0; edge=(4, 5))  # Active late\nactivate!(dnet, 20.0, 70.0; edge=(1, 5))   # Shortcut\nactivate!(dnet, 0.0, 100.0; edge=(5, 6))   # Always active\nactivate!(dnet, 5.0, 95.0; edge=(6, 7))    # Nearly always active\nactivate!(dnet, 60.0, 90.0; edge=(7, 8))   # Active mid-late\nactivate!(dnet, 0.0, 50.0; edge=(8, 9))    # Active early\nactivate!(dnet, 25.0, 75.0; edge=(9, 10))  # Active middle","category":"section"},{"location":"getting_started.html#Step-2:-Compute-Temporal-Measures","page":"Getting Started","title":"Step 2: Compute Temporal Measures","text":"","category":"section"},{"location":"getting_started.html#Centrality-at-a-Point-in-Time","page":"Getting Started","title":"Centrality at a Point in Time","text":"Compute standard centrality measures on the network snapshot at a specific time:\n\n# Degree centrality at t=30\ndeg = tDegree(dnet, 30.0)\nprintln(\"Degree at t=30: \", deg)\n\n# Directed degree\nin_deg = tDegree(dnet, 30.0; mode=:in)\nout_deg = tDegree(dnet, 30.0; mode=:out)\n\n# Betweenness centrality at t=30\nbet = tBetweenness(dnet, 30.0)\nprintln(\"Betweenness at t=30: \", round.(bet, digits=3))\n\n# Closeness centrality at t=30\nclo = tCloseness(dnet, 30.0)\nprintln(\"Closeness at t=30: \", round.(clo, digits=3))","category":"section"},{"location":"getting_started.html#Network-Level-Measures","page":"Getting Started","title":"Network-Level Measures","text":"# Density at different times\nfor t in 0.0:20.0:100.0\n    d = tDensity(dnet, t)\n    println(\"t=$t: density = $(round(d, digits=3))\")\nend\n\n# Reciprocity (directed networks)\nr = tReciprocity(dnet, 50.0)\nprintln(\"Reciprocity at t=50: $(round(r, digits=3))\")\n\n# Transitivity (clustering coefficient)\ntr = tTransitivity(dnet, 50.0)\nprintln(\"Transitivity at t=50: $(round(tr, digits=3))\")","category":"section"},{"location":"getting_started.html#Time-Series-of-Statistics","page":"Getting Started","title":"Time Series of Statistics","text":"# Compute density and reciprocity at regular intervals\ntimes = collect(0.0:10.0:100.0)\nstats = tSnaStats(dnet, times; stats=[:density, :reciprocity, :n_edges])\n\nprintln(\"Time\\tDensity\\tReciprocity\\tEdges\")\nfor (i, t) in enumerate(times)\n    d = round(stats[:density][i], digits=3)\n    r = round(stats[:reciprocity][i], digits=3)\n    e = Int(stats[:n_edges][i])\n    println(\"$t\\t$d\\t$r\\t\\t$e\")\nend","category":"section"},{"location":"getting_started.html#Step-3:-Analyze-Temporal-Paths","page":"Getting Started","title":"Step 3: Analyze Temporal Paths","text":"","category":"section"},{"location":"getting_started.html#Temporal-Distance","page":"Getting Started","title":"Temporal Distance","text":"Find the earliest arrival time from one vertex to another:\n\n# How quickly can information travel from vertex 1 to vertex 5?\ndist = temporalDistance(dnet, 1, 5, 0.0)\nprintln(\"Earliest arrival at v5 from v1 starting at t=0: $dist\")\n\n# Starting at a later time\ndist_late = temporalDistance(dnet, 1, 5, 50.0)\nprintln(\"Earliest arrival at v5 from v1 starting at t=50: $dist_late\")","category":"section"},{"location":"getting_started.html#Shortest-Temporal-Path","page":"Getting Started","title":"Shortest Temporal Path","text":"Find the actual path, not just the arrival time:\n\npath = shortestTemporalPath(dnet, 1, 5, 0.0)\n\nif !isnothing(path)\n    println(\"Path found: \", path)\n    println(\"Path length: \", length(path), \" edges\")\n    println(\"Vertices: \", path.vertices)\n    println(\"Times: \", path.times)\nelse\n    println(\"No temporal path exists\")\nend","category":"section"},{"location":"getting_started.html#Forward-Reachability","page":"Getting Started","title":"Forward Reachability","text":"Find all vertices reachable from a source:\n\n# Who can vertex 1 reach starting at t=0?\nreachable = forwardReachableSet(dnet, 1, 0.0)\nprintln(\"Vertices reachable from v1: \", reachable)\nprintln(\"Reachability: $(length(reachable))/$(nv(dnet))\")","category":"section"},{"location":"getting_started.html#Backward-Reachability","page":"Getting Started","title":"Backward Reachability","text":"Find all vertices that can reach a target:\n\n# Who can reach vertex 10 by t=100?\nsources = backwardReachableSet(dnet, 10, 100.0)\nprintln(\"Vertices that can reach v10: \", sources)","category":"section"},{"location":"getting_started.html#Step-4:-Compute-Duration-Metrics","page":"Getting Started","title":"Step 4: Compute Duration Metrics","text":"","category":"section"},{"location":"getting_started.html#Edge-Duration","page":"Getting Started","title":"Edge Duration","text":"# Mean edge duration\nmean_dur = tEdgeDuration(dnet; aggregate=:mean)\nprintln(\"Mean edge duration: $(round(mean_dur, digits=1))\")\n\n# Median edge duration\nmed_dur = tEdgeDuration(dnet; aggregate=:median)\nprintln(\"Median edge duration: $(round(med_dur, digits=1))\")\n\n# Total across all edges\ntotal_dur = tEdgeDuration(dnet; aggregate=:total)\nprintln(\"Total edge-time: $(round(total_dur, digits=1))\")\n\n# Per-edge durations\nall_durs = tEdgeDuration(dnet; aggregate=:all)\nfor (edge, dur) in all_durs\n    println(\"Edge $(edge[1])->$(edge[2]): duration = $dur\")\nend","category":"section"},{"location":"getting_started.html#Vertex-Duration","page":"Getting Started","title":"Vertex Duration","text":"# Mean vertex activity duration\nv_dur = tVertexDuration(dnet; aggregate=:mean)\nprintln(\"Mean vertex duration: $(round(v_dur, digits=1))\")","category":"section"},{"location":"getting_started.html#Edge-Persistence","page":"Getting Started","title":"Edge Persistence","text":"Measure how many edges persist across time windows:\n\n# What fraction of edges persist across 20-unit windows?\npersistence = tEdgePersistence(dnet, 20.0)\nprintln(\"Edge persistence (window=20): $(round(persistence, digits=3))\")\n\n# Try different window sizes\nfor w in [10.0, 20.0, 30.0, 50.0]\n    p = tEdgePersistence(dnet, w)\n    println(\"Window $w: persistence = $(round(p, digits=3))\")\nend","category":"section"},{"location":"getting_started.html#Turnover","page":"Getting Started","title":"Turnover","text":"Compute edge formation and dissolution rates:\n\nturnover = tTurnover(dnet, 20.0)\nprintln(\"Formation rate: $(round(turnover.formation_rate, digits=4))\")\nprintln(\"Dissolution rate: $(round(turnover.dissolution_rate, digits=4))\")\nprintln(\"New edges: $(turnover.n_formations)\")\nprintln(\"Lost edges: $(turnover.n_dissolutions)\")","category":"section"},{"location":"getting_started.html#Tie-Decay","page":"Getting Started","title":"Tie Decay","text":"Estimate the rate at which ties decay:\n\n# Exponential decay rate\ndecay = tieDecay(dnet; method=:exponential)\nprintln(\"Decay rate: $(round(decay, digits=4))\")\n\n# Halflife method\nhalflife_rate = tieDecay(dnet; method=:halflife)\nprintln(\"Halflife decay rate: $(round(halflife_rate, digits=4))\")","category":"section"},{"location":"getting_started.html#Complete-Example","page":"Getting Started","title":"Complete Example","text":"using NetworkDynamic\nusing TSNA\n\n# Build a dynamic network representing office communication\nn = 8\ndnet = DynamicNetwork(n; observation_start=0.0, observation_end=50.0)\nactivate_vertices!(dnet, collect(1:n), 0.0, 50.0)\n\n# Morning communications (0-20)\nactivate!(dnet, 0.0, 15.0; edge=(1, 2))\nactivate!(dnet, 5.0, 20.0; edge=(2, 3))\nactivate!(dnet, 3.0, 18.0; edge=(1, 4))\nactivate!(dnet, 8.0, 20.0; edge=(3, 4))\n\n# Afternoon communications (15-40)\nactivate!(dnet, 15.0, 35.0; edge=(4, 5))\nactivate!(dnet, 20.0, 40.0; edge=(5, 6))\nactivate!(dnet, 25.0, 40.0; edge=(6, 7))\nactivate!(dnet, 18.0, 38.0; edge=(5, 8))\n\n# Late communications (30-50)\nactivate!(dnet, 30.0, 50.0; edge=(7, 8))\nactivate!(dnet, 35.0, 50.0; edge=(8, 1))  # Feedback loop\nactivate!(dnet, 32.0, 48.0; edge=(2, 6))  # Cross-team link\n\n# === Analysis ===\n\n# 1. Track centrality over time\nprintln(\"=== Degree Centrality Over Time ===\")\nfor t in [5.0, 15.0, 25.0, 35.0, 45.0]\n    deg = tDegree(dnet, t)\n    top_v = argmax(deg)\n    println(\"t=$t: most central vertex = $top_v (degree=$(deg[top_v]))\")\nend\n\n# 2. Reachability analysis\nprintln(\"\\n=== Reachability from Vertex 1 ===\")\nfor t_start in [0.0, 10.0, 20.0, 30.0]\n    reach = forwardReachableSet(dnet, 1, t_start)\n    println(\"Starting at t=$t_start: $(length(reach)) vertices reachable\")\nend\n\n# 3. Temporal paths\nprintln(\"\\n=== Shortest Paths from v1 ===\")\nfor target in [4, 6, 8]\n    path = shortestTemporalPath(dnet, 1, target, 0.0)\n    if !isnothing(path)\n        println(\"v1 -> v$target: $(length(path)) edges, arrival at t=$(path.times[end])\")\n    else\n        println(\"v1 -> v$target: no path\")\n    end\nend\n\n# 4. Duration metrics\nprintln(\"\\n=== Duration Metrics ===\")\nprintln(\"Mean edge duration: $(round(tEdgeDuration(dnet; aggregate=:mean), digits=1))\")\nprintln(\"Edge persistence (window=10): $(round(tEdgePersistence(dnet, 10.0), digits=3))\")\n\nturnover = tTurnover(dnet, 10.0)\nprintln(\"Formation rate: $(round(turnover.formation_rate, digits=4))\")\nprintln(\"Dissolution rate: $(round(turnover.dissolution_rate, digits=4))\")\n\n# 5. Network evolution\nprintln(\"\\n=== Network Evolution ===\")\ntimes = collect(0.0:5.0:50.0)\nstats = tSnaStats(dnet, times; stats=[:density, :n_edges, :mean_degree])\nfor (i, t) in enumerate(times)\n    println(\"t=$t: edges=$(Int(stats[:n_edges][i])), \",\n            \"density=$(round(stats[:density][i], digits=3)), \",\n            \"mean_deg=$(round(stats[:mean_degree][i], digits=2))\")\nend","category":"section"},{"location":"getting_started.html#Working-with-Contact-Sequences","page":"Getting Started","title":"Working with Contact Sequences","text":"Convert a dynamic network to a sequence of contacts:\n\ncs = as_contact_sequence(dnet)\nprintln(\"Number of contacts: \", length(cs))\n\nfor contact in cs\n    println(\"$(contact.source) -> $(contact.target) at t=$(contact.time), \",\n            \"duration=$(contact.duration)\")\nend","category":"section"},{"location":"getting_started.html#Aggregating-to-Static-Networks","page":"Getting Started","title":"Aggregating to Static Networks","text":"Collapse a dynamic network to static using different methods:\n\n# Union: include any edge that was ever active\nstatic_union = tAggregate(dnet; method=:union)\nprintln(\"Union: $(ne(static_union)) edges\")\n\n# Intersection: include only edges active throughout\nstatic_inter = tAggregate(dnet; method=:intersection)\nprintln(\"Intersection: $(ne(static_inter)) edges\")\n\n# Weighted: weight by total activity time\nstatic_weighted = tAggregate(dnet; method=:weighted)\nprintln(\"Weighted: $(ne(static_weighted)) edges\")","category":"section"},{"location":"getting_started.html#Best-Practices","page":"Getting Started","title":"Best Practices","text":"Define observation period: Always set observation_start and observation_end on the dynamic network\nActivate vertices: Ensure all vertices are active before querying centrality at specific times\nCheck for empty snapshots: Some time points may have no active vertices or edges\nUse appropriate window sizes: For persistence and turnover, window size should match your analysis timescale\nCompare with static analysis: Temporal measures should reveal dynamics invisible to static SNA\nConsider edge direction: Temporal paths in directed networks can only follow edge direction","category":"section"},{"location":"getting_started.html#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Learn about Temporal Centrality measures in detail\nUnderstand Temporal Paths and reachability analysis\nExplore Duration Metrics for measuring network dynamics","category":"section"},{"location":"api/metrics.html#Metrics-API-Reference","page":"Metrics","title":"Metrics API Reference","text":"This page documents the duration, persistence, and aggregation functions in TSNA.jl.","category":"section"},{"location":"api/metrics.html#Duration-Metrics","page":"Metrics","title":"Duration Metrics","text":"","category":"section"},{"location":"api/metrics.html#Persistence-and-Turnover","page":"Metrics","title":"Persistence and Turnover","text":"","category":"section"},{"location":"api/metrics.html#Aggregation","page":"Metrics","title":"Aggregation","text":"","category":"section"},{"location":"api/metrics.html#TSNA.tEdgeDuration","page":"Metrics","title":"TSNA.tEdgeDuration","text":"tEdgeDuration(dnet::DynamicNetwork; aggregate=:mean) -> Union{Float64, Dict}\n\nCompute edge duration statistics.\n\nArguments\n\naggregate: :mean, :median, :total, or :all for per-edge values\n\n\n\n\n\n","category":"function"},{"location":"api/metrics.html#TSNA.tVertexDuration","page":"Metrics","title":"TSNA.tVertexDuration","text":"tVertexDuration(dnet::DynamicNetwork; aggregate=:mean) -> Union{Float64, Vector}\n\nCompute vertex activity duration statistics.\n\n\n\n\n\n","category":"function"},{"location":"api/metrics.html#TSNA.tEdgePersistence","page":"Metrics","title":"TSNA.tEdgePersistence","text":"tEdgePersistence(dnet::DynamicNetwork, window_size::Time) -> Float64\n\nCompute the proportion of edges that persist across time windows.\n\n\n\n\n\n","category":"function"},{"location":"api/metrics.html#TSNA.tTurnover","page":"Metrics","title":"TSNA.tTurnover","text":"tTurnover(dnet::DynamicNetwork, window_size::Time) -> NamedTuple\n\nCompute edge turnover (formation and dissolution rates).\n\n\n\n\n\n","category":"function"},{"location":"api/metrics.html#TSNA.tieDecay","page":"Metrics","title":"TSNA.tieDecay","text":"tieDecay(dnet::DynamicNetwork; method=:exponential) -> Float64\n\nEstimate tie decay rate from observed data.\n\n\n\n\n\n","category":"function"},{"location":"api/metrics.html#TSNA.tAggregate","page":"Metrics","title":"TSNA.tAggregate","text":"tAggregate(dnet::DynamicNetwork; method=:union) -> Network\n\nAggregate dynamic network to static using specified method.\n\nMethods\n\n:union: Include edge if ever active\n:intersection: Include edge if always active\n:weighted: Create weighted network by total activation time\n\n\n\n\n\n","category":"function"},{"location":"guide/paths.html#Temporal-Paths","page":"Temporal Paths","title":"Temporal Paths","text":"This guide covers temporal path analysis in TSNA.jl, including time-respecting paths, temporal distance, and reachability analysis.","category":"section"},{"location":"guide/paths.html#What-are-Temporal-Paths?","page":"Temporal Paths","title":"What are Temporal Paths?","text":"In a static network, a path from A to C through B is valid whenever edges A to B and B to C exist. In a temporal network, a path must also respect time – you can only traverse an edge while it is active, and edges must be traversed in non-decreasing time order.\n\nStatic:     A → B → C    (always valid if both edges exist)\n\nTemporal:   A --(t=5)--> B --(t=10)--> C    (valid: 5 <= 10)\n            A --(t=5)--> B --(t=3)--> C     (INVALID: 3 < 5, going back in time)\n\nThis constraint fundamentally changes reachability. In temporal networks:\n\nReachability depends on the start time\nReachability is not symmetric: A can reach B does not imply B can reach A\nReachability is not transitive: A reaches B and B reaches C does not guarantee A reaches C","category":"section"},{"location":"guide/paths.html#The-tPath-Type","page":"Temporal Paths","title":"The tPath Type","text":"Temporal paths are represented by the tPath{T, Time} type:\n\nstruct tPath{T, Time}\n    vertices::Vector{T}       # Sequence of vertices visited\n    times::Vector{Time}       # Time at each edge traversal\n    edges::Vector{Tuple{T,T}} # Edges traversed\nend","category":"section"},{"location":"guide/paths.html#Properties","page":"Temporal Paths","title":"Properties","text":"length(path) returns the number of edges (hops)\npath.vertices[1] is the source\npath.vertices[end] is the target\npath.times[i] is the time of the i-th edge traversal\npath.edges[i] is the i-th edge","category":"section"},{"location":"guide/paths.html#Example","page":"Temporal Paths","title":"Example","text":"# A path: 1 --(t=5)--> 2 --(t=10)--> 3 --(t=15)--> 4\npath = tPath(\n    [1, 2, 3, 4],                    # vertices\n    [5.0, 10.0, 15.0],               # times\n    [(1, 2), (2, 3), (3, 4)]         # edges\n)\n\nprintln(path)\n# tPath: 1 --(5.0)--> 2 --(10.0)--> 3 --(15.0)--> 4\n\nprintln(\"Length: \", length(path))  # 3 edges\nprintln(\"Source: \", path.vertices[1])  # 1\nprintln(\"Target: \", path.vertices[end])  # 4\nprintln(\"Departure: \", path.times[1])  # 5.0\nprintln(\"Arrival: \", path.times[end])  # 15.0","category":"section"},{"location":"guide/paths.html#Temporal-Distance","page":"Temporal Paths","title":"Temporal Distance","text":"","category":"section"},{"location":"guide/paths.html#Finding-Earliest-Arrival","page":"Temporal Paths","title":"Finding Earliest Arrival","text":"The temporalDistance function finds the earliest time at which a target vertex can be reached from a source, starting at a given time:\n\nusing NetworkDynamic\nusing TSNA\n\n# Create network with sequential edges\ndnet = DynamicNetwork(5; observation_start=0.0, observation_end=100.0)\nactivate_vertices!(dnet, collect(1:5), 0.0, 100.0)\n\nactivate!(dnet, 0.0, 20.0; edge=(1, 2))   # Active early\nactivate!(dnet, 10.0, 40.0; edge=(2, 3))  # Overlaps\nactivate!(dnet, 30.0, 60.0; edge=(3, 4))  # Later\nactivate!(dnet, 50.0, 80.0; edge=(4, 5))  # Even later\n\n# Earliest arrival from 1 to 5, starting at t=0\ndist = temporalDistance(dnet, 1, 5, 0.0)\nprintln(\"Earliest arrival at v5: $dist\")\n# Path: 1→2 at t=0, 2→3 at t=10, 3→4 at t=30, 4→5 at t=50\n# Arrival: t=50\n\n# Starting later\ndist2 = temporalDistance(dnet, 1, 5, 25.0)\nprintln(\"Starting at t=25: $dist2\")\n# Edge (1,2) is still active at t=25, but we need subsequent edges","category":"section"},{"location":"guide/paths.html#When-No-Path-Exists","page":"Temporal Paths","title":"When No Path Exists","text":"If no temporal path exists, temporalDistance returns Inf:\n\n# No path exists if we start too late\ndist = temporalDistance(dnet, 1, 5, 90.0)\nif isinf(dist)\n    println(\"No temporal path exists starting at t=90\")\nend","category":"section"},{"location":"guide/paths.html#Self-Distance","page":"Temporal Paths","title":"Self-Distance","text":"The distance from a vertex to itself is the start time:\n\ndist = temporalDistance(dnet, 1, 1, 5.0)\nprintln(dist)  # 5.0","category":"section"},{"location":"guide/paths.html#Shortest-Temporal-Path","page":"Temporal Paths","title":"Shortest Temporal Path","text":"","category":"section"},{"location":"guide/paths.html#Finding-the-Path","page":"Temporal Paths","title":"Finding the Path","text":"The shortestTemporalPath function returns the actual path, not just the arrival time:\n\npath = shortestTemporalPath(dnet, 1, 5, 0.0)\n\nif !isnothing(path)\n    println(\"Path found!\")\n    println(\"Vertices: \", path.vertices)\n    println(\"Times: \", path.times)\n    println(\"Edges: \", path.edges)\n    println(\"Total hops: \", length(path))\nelse\n    println(\"No path exists\")\nend","category":"section"},{"location":"guide/paths.html#Path-to-Self","page":"Temporal Paths","title":"Path to Self","text":"path = shortestTemporalPath(dnet, 1, 1, 0.0)\nprintln(path)\n# tPath: 1  (trivial path, no edges)\nprintln(length(path))  # 0","category":"section"},{"location":"guide/paths.html#Algorithm","page":"Temporal Paths","title":"Algorithm","text":"The shortest temporal path algorithm works as follows:\n\nInitialize earliest arrival times: textarrivals = t_textstart, all others = infty\nSort all edge spells by onset time (ascending)\nFor each edge activation (i j) at time t:\nIf vertex i has been reached by time t (i.e., textarrivali leq t):\nIf t  textarrivalj: update textarrivalj = t and record predecessor\nReconstruct path from predecessor chain\n\nThis is a temporal adaptation of Dijkstra's algorithm, taking advantage of the fact that edge activations can be processed in time order.","category":"section"},{"location":"guide/paths.html#Reachability-Analysis","page":"Temporal Paths","title":"Reachability Analysis","text":"","category":"section"},{"location":"guide/paths.html#Forward-Reachability","page":"Temporal Paths","title":"Forward Reachability","text":"The forward reachable set contains all vertices that can be reached from a source starting at a given time:\n\n# Who can vertex 1 reach starting at t=0?\nreachable = forwardReachableSet(dnet, 1, 0.0)\nprintln(\"Forward reachable from v1 at t=0: \", reachable)\nprintln(\"Fraction reachable: $(length(reachable))/$(nv(dnet))\")","category":"section"},{"location":"guide/paths.html#Backward-Reachability","page":"Temporal Paths","title":"Backward Reachability","text":"The backward reachable set contains all vertices that can reach a target by a given time:\n\n# Who can reach vertex 5 by t=100?\nsources = backwardReachableSet(dnet, 5, 100.0)\nprintln(\"Backward reachable to v5 by t=100: \", sources)","category":"section"},{"location":"guide/paths.html#Reachability-Properties","page":"Temporal Paths","title":"Reachability Properties","text":"# Forward reachability always includes the source\nreach = forwardReachableSet(dnet, 1, 0.0)\n@assert 1 in reach\n\n# Backward reachability always includes the target\nsources = backwardReachableSet(dnet, 5, 100.0)\n@assert 5 in sources","category":"section"},{"location":"guide/paths.html#Reachability-Over-Time","page":"Temporal Paths","title":"Reachability Over Time","text":"Track how reachability changes with the start time:\n\nsource = 1\nprintln(\"Forward reachability from v$source:\")\nfor t_start in 0.0:10.0:90.0\n    reach = forwardReachableSet(dnet, source, t_start)\n    println(\"  Start at t=$t_start: $(length(reach)) vertices reachable\")\nend\n\nAs the start time increases, fewer future edge activations are available, so reachability typically decreases.","category":"section"},{"location":"guide/paths.html#Practical-Examples","page":"Temporal Paths","title":"Practical Examples","text":"","category":"section"},{"location":"guide/paths.html#Information-Spread-Analysis","page":"Temporal Paths","title":"Information Spread Analysis","text":"Analyze how quickly information can spread through a network:\n\ndnet = DynamicNetwork(20; observation_start=0.0, observation_end=100.0)\nactivate_vertices!(dnet, collect(1:20), 0.0, 100.0)\n\n# Add edges (communication events)\n# ... (add many edges with various activity spells)\n\n# How many vertices can be reached from vertex 1 at different times?\nsource = 1\nprintln(\"Information spread from vertex $source:\")\nfor t in 0.0:10.0:100.0\n    reach = forwardReachableSet(dnet, source, t)\n    println(\"  Starting at t=$t: $(length(reach)) vertices reachable\")\nend\n\n# What fraction of all pairs are temporally connected?\nn = nv(dnet)\nconnected_pairs = 0\ntotal_pairs = n * (n - 1)\n\nfor s in 1:n\n    reach = forwardReachableSet(dnet, s, 0.0)\n    connected_pairs += length(reach) - 1  # Exclude self\nend\n\nprintln(\"Temporal connectivity: $(connected_pairs)/$(total_pairs) = \",\n        \"$(round(connected_pairs/total_pairs, digits=3))\")","category":"section"},{"location":"guide/paths.html#Earliest-Delivery-Analysis","page":"Temporal Paths","title":"Earliest Delivery Analysis","text":"Find the earliest time each vertex can receive information from a source:\n\nsource = 1\nstart_time = 0.0\n\nprintln(\"Earliest arrival from vertex $source:\")\nfor target in 1:nv(dnet)\n    target == source && continue\n    dist = temporalDistance(dnet, source, target, start_time)\n    if isinf(dist)\n        println(\"  v$target: unreachable\")\n    else\n        println(\"  v$target: arrives at t=$dist\")\n    end\nend","category":"section"},{"location":"guide/paths.html#Path-Analysis","page":"Temporal Paths","title":"Path Analysis","text":"Compare paths from different starting times:\n\nsource = 1\ntarget = 10\n\nprintln(\"Paths from v$source to v$target:\")\nfor t_start in 0.0:20.0:80.0\n    path = shortestTemporalPath(dnet, source, target, t_start)\n    if !isnothing(path)\n        println(\"  Start t=$t_start: $(length(path)) hops, \",\n                \"arrival at t=$(path.times[end])\")\n    else\n        println(\"  Start t=$t_start: no path\")\n    end\nend","category":"section"},{"location":"guide/paths.html#Bidirectional-Reachability","page":"Temporal Paths","title":"Bidirectional Reachability","text":"Find vertices that can both reach and be reached by a focal vertex:\n\nfocal = 1\n\n# Forward: who can focal reach?\nforward = forwardReachableSet(dnet, focal, 0.0)\n\n# Backward: who can reach focal?\nbackward = backwardReachableSet(dnet, focal, 100.0)\n\n# Bidirectional: both forward and backward reachable\nbidirectional = intersect(forward, backward)\n\nprintln(\"Forward reachable: $(length(forward))\")\nprintln(\"Backward reachable: $(length(backward))\")\nprintln(\"Bidirectional: $(length(bidirectional))\")","category":"section"},{"location":"guide/paths.html#Computational-Complexity","page":"Temporal Paths","title":"Computational Complexity","text":"Function Complexity Notes\ntemporalDistance O(E log E) E = total edge spells\nshortestTemporalPath O(E log E + P) P = path reconstruction\nforwardReachableSet O(E log E) Same as temporalDistance\nbackwardReachableSet O(E log E) Reverse time processing\n\nAll algorithms sort edge spells by onset time, then process them in order. The dominant cost is the sort, making them efficient for networks with many vertices but moderate numbers of edge spells.","category":"section"},{"location":"guide/paths.html#Best-Practices","page":"Temporal Paths","title":"Best Practices","text":"Choose appropriate start times: Reachability depends strongly on the start time\nConsider direction: In directed networks, forward and backward reachability differ\nCheck for Inf: Always check if temporalDistance returns Inf before using the result\nUse forward reachability for spread: Forward reachable sets model information or disease spread\nUse backward reachability for influence: Backward reachable sets identify potential sources of influence\nTrack over time: Compute reachability at multiple start times to understand dynamics","category":"section"},{"location":"api/centrality.html#Centrality-API-Reference","page":"Centrality","title":"Centrality API Reference","text":"This page documents the temporal centrality functions in TSNA.jl.","category":"section"},{"location":"api/centrality.html#Vertex-Centrality","page":"Centrality","title":"Vertex Centrality","text":"Centrality measures computed on network snapshots at specific time points.","category":"section"},{"location":"api/centrality.html#Network-Level-Measures","page":"Centrality","title":"Network-Level Measures","text":"Global network statistics computed at specific time points.","category":"section"},{"location":"api/centrality.html#Time-Series","page":"Centrality","title":"Time Series","text":"Functions for computing statistics at multiple time points or in sliding windows.","category":"section"},{"location":"api/centrality.html#TSNA.tDegree","page":"Centrality","title":"TSNA.tDegree","text":"tDegree(dnet::DynamicNetwork, at::Time; mode=:total) -> Vector{Int}\n\nCompute degree centrality at a specific time point.\n\nArguments\n\ndnet: Dynamic network\nat: Time point\nmode: :in, :out, or :total for directed networks\n\n\n\n\n\n","category":"function"},{"location":"api/centrality.html#TSNA.tBetweenness","page":"Centrality","title":"TSNA.tBetweenness","text":"tBetweenness(dnet::DynamicNetwork, at::Time; normalized=true) -> Vector{Float64}\n\nCompute betweenness centrality at a specific time point.\n\n\n\n\n\n","category":"function"},{"location":"api/centrality.html#TSNA.tCloseness","page":"Centrality","title":"TSNA.tCloseness","text":"tCloseness(dnet::DynamicNetwork, at::Time) -> Vector{Float64}\n\nCompute closeness centrality at a specific time point.\n\n\n\n\n\n","category":"function"},{"location":"api/centrality.html#TSNA.tEigenvector","page":"Centrality","title":"TSNA.tEigenvector","text":"tEigenvector(dnet::DynamicNetwork, at::Time) -> Vector{Float64}\n\nCompute eigenvector centrality at a specific time point.\n\n\n\n\n\n","category":"function"},{"location":"api/centrality.html#TSNA.tPagerank","page":"Centrality","title":"TSNA.tPagerank","text":"tPagerank(dnet::DynamicNetwork, at::Time; damping=0.85) -> Vector{Float64}\n\nCompute PageRank at a specific time point.\n\n\n\n\n\n","category":"function"},{"location":"api/centrality.html#TSNA.tDensity","page":"Centrality","title":"TSNA.tDensity","text":"tDensity(dnet::DynamicNetwork, at::Time) -> Float64\n\nCompute network density at a specific time point.\n\n\n\n\n\n","category":"function"},{"location":"api/centrality.html#TSNA.tReciprocity","page":"Centrality","title":"TSNA.tReciprocity","text":"tReciprocity(dnet::DynamicNetwork, at::Time) -> Float64\n\nCompute reciprocity at a specific time point (directed networks).\n\n\n\n\n\n","category":"function"},{"location":"api/centrality.html#TSNA.tTransitivity","page":"Centrality","title":"TSNA.tTransitivity","text":"tTransitivity(dnet::DynamicNetwork, at::Time) -> Float64\n\nCompute transitivity (clustering coefficient) at a specific time point.\n\n\n\n\n\n","category":"function"},{"location":"api/centrality.html#TSNA.tSnaStats","page":"Centrality","title":"TSNA.tSnaStats","text":"tSnaStats(dnet::DynamicNetwork, times::AbstractVector{Time};\n          stats::Vector{Symbol}=[:density, :reciprocity]) -> Dict{Symbol, Vector}\n\nCompute SNA statistics at multiple time points.\n\n\n\n\n\n","category":"function"},{"location":"api/centrality.html#TSNA.windowSnaStats","page":"Centrality","title":"TSNA.windowSnaStats","text":"windowSnaStats(dnet::DynamicNetwork, window_size::Time;\n               stats::Vector{Symbol}=[:density]) -> Dict{Symbol, Vector}\n\nCompute SNA statistics in sliding windows.\n\n\n\n\n\n","category":"function"},{"location":"guide/centrality.html#Temporal-Centrality","page":"Temporal Centrality","title":"Temporal Centrality","text":"This guide covers the temporal centrality measures available in TSNA.jl. These measures compute standard centrality metrics on network snapshots extracted at specific time points.","category":"section"},{"location":"guide/centrality.html#Overview","page":"Temporal Centrality","title":"Overview","text":"Temporal centrality measures answer the question: \"Who is most central at a given time?\" Unlike static centrality, temporal centrality can change as the network evolves – a vertex that is highly central at one time may be peripheral at another.\n\nAll temporal centrality functions in TSNA.jl follow the same pattern:\n\ncentrality_values = tCentrality(dnet, at_time; options...)\n\nThey work by:\n\nExtracting a static network snapshot at the specified time using network_extract\nComputing the standard centrality measure on the snapshot using Graphs.jl algorithms\nReturning a vector of centrality values, one per active vertex","category":"section"},{"location":"guide/centrality.html#Degree-Centrality","page":"Temporal Centrality","title":"Degree Centrality","text":"","category":"section"},{"location":"guide/centrality.html#tDegree","page":"Temporal Centrality","title":"tDegree","text":"Degree centrality counts the number of edges incident to each vertex:\n\nusing NetworkDynamic\nusing TSNA\n\n# Create dynamic network\ndnet = DynamicNetwork(10; observation_start=0.0, observation_end=100.0)\nactivate_vertices!(dnet, collect(1:10), 0.0, 100.0)\nactivate!(dnet, 0.0, 50.0; edge=(1, 2))\nactivate!(dnet, 0.0, 50.0; edge=(1, 3))\nactivate!(dnet, 0.0, 100.0; edge=(2, 3))\nactivate!(dnet, 50.0, 100.0; edge=(4, 5))\n\n# Total degree at t=25\ndeg = tDegree(dnet, 25.0)\nprintln(\"Degree at t=25: \", deg)","category":"section"},{"location":"guide/centrality.html#Directed-Degree-Modes","page":"Temporal Centrality","title":"Directed Degree Modes","text":"For directed networks, specify the degree mode:\n\n# In-degree (number of incoming edges)\nin_deg = tDegree(dnet, 25.0; mode=:in)\n\n# Out-degree (number of outgoing edges)\nout_deg = tDegree(dnet, 25.0; mode=:out)\n\n# Total degree (in + out, default)\ntotal_deg = tDegree(dnet, 25.0; mode=:total)\n\nMode Counts Interpretation\n:in Incoming edges Popularity, prestige\n:out Outgoing edges Activity, influence\n:total Both directions Overall connectivity","category":"section"},{"location":"guide/centrality.html#Degree-Over-Time","page":"Temporal Centrality","title":"Degree Over Time","text":"Track how a vertex's degree changes:\n\ntimes = collect(0.0:10.0:100.0)\nv = 1  # Track vertex 1\n\nprintln(\"Vertex $v degree over time:\")\nfor t in times\n    deg = tDegree(dnet, t)\n    if v <= length(deg)\n        println(\"  t=$t: degree=$(deg[v])\")\n    end\nend","category":"section"},{"location":"guide/centrality.html#Betweenness-Centrality","page":"Temporal Centrality","title":"Betweenness Centrality","text":"","category":"section"},{"location":"guide/centrality.html#tBetweenness","page":"Temporal Centrality","title":"tBetweenness","text":"Betweenness centrality measures how often a vertex lies on shortest paths between other vertices:\n\nbet = tBetweenness(dnet, 50.0)\nprintln(\"Betweenness at t=50: \", round.(bet, digits=3))\n\n# Unnormalized\nbet_raw = tBetweenness(dnet, 50.0; normalized=false)\n\nParameter Description Default\nnormalized Normalize by (n-1)(n-2) true\n\nInterpretation: A vertex with high betweenness acts as a bridge or broker between different parts of the network. Temporal betweenness reveals when these brokerage positions exist.","category":"section"},{"location":"guide/centrality.html#Temporal-Brokerage-Analysis","page":"Temporal Centrality","title":"Temporal Brokerage Analysis","text":"# Track betweenness over time to find when vertices serve as brokers\ntimes = collect(0.0:5.0:100.0)\nn = nv(dnet)\n\nprintln(\"Peak brokerage times:\")\nfor v in 1:n\n    max_bet = 0.0\n    max_t = 0.0\n    for t in times\n        bet = tBetweenness(dnet, t)\n        if v <= length(bet) && bet[v] > max_bet\n            max_bet = bet[v]\n            max_t = t\n        end\n    end\n    if max_bet > 0\n        println(\"  Vertex $v: peak betweenness=$(round(max_bet, digits=3)) at t=$max_t\")\n    end\nend","category":"section"},{"location":"guide/centrality.html#Closeness-Centrality","page":"Temporal Centrality","title":"Closeness Centrality","text":"","category":"section"},{"location":"guide/centrality.html#tCloseness","page":"Temporal Centrality","title":"tCloseness","text":"Closeness centrality measures how close a vertex is to all other vertices (inverse of average shortest path length):\n\nclo = tCloseness(dnet, 50.0)\nprintln(\"Closeness at t=50: \", round.(clo, digits=3))\n\nInterpretation: High closeness indicates a vertex can quickly reach (or be reached by) all others. In temporal networks, closeness can change dramatically as edges activate and deactivate.","category":"section"},{"location":"guide/centrality.html#Comparing-Centrality-Measures","page":"Temporal Centrality","title":"Comparing Centrality Measures","text":"t = 50.0\ndeg = tDegree(dnet, t)\nbet = tBetweenness(dnet, t)\nclo = tCloseness(dnet, t)\n\nprintln(\"Vertex\\tDegree\\tBetween\\tCloseness\")\nfor v in 1:length(deg)\n    println(\"$v\\t$(deg[v])\\t$(round(bet[v], digits=3))\\t$(round(clo[v], digits=3))\")\nend","category":"section"},{"location":"guide/centrality.html#Eigenvector-Centrality","page":"Temporal Centrality","title":"Eigenvector Centrality","text":"","category":"section"},{"location":"guide/centrality.html#tEigenvector","page":"Temporal Centrality","title":"tEigenvector","text":"Eigenvector centrality measures a vertex's influence based on the influence of its neighbors:\n\neig = tEigenvector(dnet, 50.0)\nprintln(\"Eigenvector centrality at t=50: \", round.(eig, digits=3))\n\nInterpretation: A vertex has high eigenvector centrality when it is connected to other well-connected vertices. This captures \"influence\" in a recursive sense.\n\nNote: Eigenvector centrality may not converge for disconnected networks. If the snapshot at time t is disconnected, results should be interpreted with caution.","category":"section"},{"location":"guide/centrality.html#PageRank","page":"Temporal Centrality","title":"PageRank","text":"","category":"section"},{"location":"guide/centrality.html#tPagerank","page":"Temporal Centrality","title":"tPagerank","text":"PageRank is a variant of eigenvector centrality with a damping factor, originally designed for ranking web pages:\n\npr = tPagerank(dnet, 50.0)\nprintln(\"PageRank at t=50: \", round.(pr, digits=3))\n\n# With custom damping factor\npr_low = tPagerank(dnet, 50.0; damping=0.5)\npr_high = tPagerank(dnet, 50.0; damping=0.95)\n\nParameter Description Default\ndamping Probability of following an edge (vs. random jump) 0.85\n\nInterpretation: PageRank handles disconnected networks better than eigenvector centrality due to the random jump component. Lower damping means more random jumps, leading to more uniform values.","category":"section"},{"location":"guide/centrality.html#Network-Level-Temporal-Measures","page":"Temporal Centrality","title":"Network-Level Temporal Measures","text":"","category":"section"},{"location":"guide/centrality.html#tDensity","page":"Temporal Centrality","title":"tDensity","text":"Network density at a specific time:\n\nd = tDensity(dnet, 50.0)\nprintln(\"Density at t=50: $(round(d, digits=3))\")\n\nDensity equals the number of active edges divided by the maximum possible edges.","category":"section"},{"location":"guide/centrality.html#tReciprocity","page":"Temporal Centrality","title":"tReciprocity","text":"Proportion of edges that are reciprocated (directed networks):\n\nr = tReciprocity(dnet, 50.0)\nprintln(\"Reciprocity at t=50: $(round(r, digits=3))\")\n\nFor undirected networks, reciprocity is always 1.0.","category":"section"},{"location":"guide/centrality.html#tTransitivity","page":"Temporal Centrality","title":"tTransitivity","text":"Global clustering coefficient (transitivity):\n\ntr = tTransitivity(dnet, 50.0)\nprintln(\"Transitivity at t=50: $(round(tr, digits=3))\")\n\nTransitivity measures the proportion of connected triples that form triangles.","category":"section"},{"location":"guide/centrality.html#Computing-Statistics-Over-Time","page":"Temporal Centrality","title":"Computing Statistics Over Time","text":"","category":"section"},{"location":"guide/centrality.html#Point-in-Time-Statistics","page":"Temporal Centrality","title":"Point-in-Time Statistics","text":"Use tSnaStats to compute multiple statistics at a series of time points:\n\ntimes = collect(0.0:10.0:100.0)\nstats = tSnaStats(dnet, times;\n    stats=[:density, :reciprocity, :transitivity, :n_edges, :n_vertices, :mean_degree]\n)\n\n# Access results\ndensities = stats[:density]\nreciprocities = stats[:reciprocity]\nedge_counts = stats[:n_edges]\n\n# Print table\nprintln(\"Time\\tDensity\\tRecip\\tEdges\\tMean Deg\")\nfor (i, t) in enumerate(times)\n    println(\"$(t)\\t$(round(stats[:density][i], digits=3))\\t\",\n            \"$(round(stats[:reciprocity][i], digits=3))\\t\",\n            \"$(Int(stats[:n_edges][i]))\\t\",\n            \"$(round(stats[:mean_degree][i], digits=2))\")\nend","category":"section"},{"location":"guide/centrality.html#Available-Statistics","page":"Temporal Centrality","title":"Available Statistics","text":"Symbol Description\n:density Network density\n:reciprocity Proportion of reciprocated edges\n:transitivity Global clustering coefficient\n:n_edges Number of active edges\n:n_vertices Number of active vertices\n:mean_degree Mean degree (2 * edges / vertices)","category":"section"},{"location":"guide/centrality.html#Window-Based-Statistics","page":"Temporal Centrality","title":"Window-Based Statistics","text":"Use windowSnaStats to compute statistics in sliding windows rather than at point-in-time snapshots:\n\n# Statistics in 10-unit windows with 5-unit step\nstats = windowSnaStats(dnet, 10.0;\n    stats=[:density, :n_edges],\n    step=5.0\n)\n\nprintln(\"Window densities: \", round.(stats[:density], digits=3))\nprintln(\"Window edge counts: \", stats[:n_edges])\n\nThe window extraction uses network_extract(dnet, t, t+window_size; rule=:any), including all elements active at any point during the window.","category":"section"},{"location":"guide/centrality.html#Practical-Considerations","page":"Temporal Centrality","title":"Practical Considerations","text":"","category":"section"},{"location":"guide/centrality.html#Empty-Snapshots","page":"Temporal Centrality","title":"Empty Snapshots","text":"At some time points, no vertices or edges may be active:\n\ndeg = tDegree(dnet, 200.0)  # After observation period\n# May return empty vector or zeros\n\nAlways check that the snapshot has sufficient vertices before computing centrality.","category":"section"},{"location":"guide/centrality.html#Vertex-Re-indexing","page":"Temporal Centrality","title":"Vertex Re-indexing","text":"When extracting snapshots, only active vertices are included and re-indexed. This means vertex IDs in the centrality vector may not correspond to the original vertex IDs:\n\n# If vertices 3, 5, 7 are active at t=50\n# deg[1] corresponds to vertex 3\n# deg[2] corresponds to vertex 5\n# deg[3] corresponds to vertex 7","category":"section"},{"location":"guide/centrality.html#Disconnected-Components","page":"Temporal Centrality","title":"Disconnected Components","text":"Some centrality measures (closeness, eigenvector) may behave unexpectedly on disconnected networks. Consider:\n\nUsing PageRank instead of eigenvector centrality for disconnected networks\nRestricting analysis to the largest connected component\nChecking the number of components before computing centrality","category":"section"},{"location":"guide/centrality.html#Best-Practices","page":"Temporal Centrality","title":"Best Practices","text":"Check snapshot size: Verify the extracted network has enough vertices for meaningful centrality\nUse appropriate measures: Degree for local connectivity, betweenness for brokerage, PageRank for global influence\nTrack over time: Compute centrality at multiple time points to reveal dynamics\nCompare measures: Different centrality measures highlight different aspects of temporal importance\nConsider direction: Use :in and :out modes for directed networks to distinguish popularity from activity\nWindow vs. point: Use tSnaStats for point-in-time snapshots, windowSnaStats for aggregated views","category":"section"},{"location":"index.html#TSNA.jl","page":"Home","title":"TSNA.jl","text":"Temporal Social Network Analysis for Julia\n\nA Julia package for descriptive analysis of dynamic networks, including temporal centrality measures, time-respecting path analysis, reachability, and duration metrics.","category":"section"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"Social network analysis traditionally operates on static network snapshots. TSNA.jl extends these methods to dynamic networks where vertices and edges appear and disappear over time. It provides tools for computing temporal versions of classical SNA measures, finding time-respecting paths, analyzing reachability, and computing duration and turnover metrics.\n\nTSNA.jl is a port of the R tsna package from the StatNet collection.","category":"section"},{"location":"index.html#What-is-Temporal-SNA?","page":"Home","title":"What is Temporal SNA?","text":"Temporal SNA applies descriptive network analysis to time-varying networks. Unlike static SNA, temporal analysis respects the ordering of time – an actor can only influence another through a sequence of contacts that occur in non-decreasing time order.\n\nStatic view:    A -- B -- C     (A can reach C through B)\nTemporal view:  A --(t=5)--> B --(t=3)--> C    (A cannot reach C: edge B->C occurs before A->B)","category":"section"},{"location":"index.html#Key-Concepts","page":"Home","title":"Key Concepts","text":"Concept Description\nTemporal Centrality Centrality measures computed on network snapshots at specific times\nTemporal Path A path where edge traversals occur in non-decreasing time order\nTemporal Distance Earliest arrival time from source to target\nForward Reachability Set of vertices reachable from a source after a start time\nBackward Reachability Set of vertices that can reach a target before an end time\nEdge Duration Total time an edge is active\nTurnover Rate of edge formation and dissolution","category":"section"},{"location":"index.html#Applications","page":"Home","title":"Applications","text":"Temporal SNA is used in:\n\nEpidemiology: Modeling disease spread through time-varying contact networks\nInformation diffusion: How quickly can information reach all actors?\nOrganizational dynamics: Measuring evolving influence and centrality\nCommunication networks: Analyzing temporal patterns in email or messaging data\nTransportation: Time-constrained routing through dynamic networks\nAnimal behavior: Studying temporal interaction patterns","category":"section"},{"location":"index.html#Features","page":"Home","title":"Features","text":"Temporal centrality: Time-varying degree, betweenness, closeness, eigenvector, and PageRank\nTemporal paths: Find shortest time-respecting paths and earliest arrival times\nReachability analysis: Forward and backward reachable sets from any vertex\nDuration metrics: Edge and vertex activity duration, persistence, and turnover rates\nContact sequences: Convert dynamic networks to temporal contact sequences\nAggregation: Compute statistics at multiple time points or in sliding windows\nNetwork aggregation: Collapse dynamic networks using union, intersection, or weighted methods","category":"section"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/Statistical-network-analysis-with-Julia/TSNA.jl\")\n\nOr for development:\n\nusing Pkg\nPkg.develop(path=\"/path/to/TSNA.jl\")","category":"section"},{"location":"index.html#Quick-Start","page":"Home","title":"Quick Start","text":"using NetworkDynamic\nusing TSNA\n\n# Create a dynamic network\ndnet = DynamicNetwork(10; observation_start=0.0, observation_end=100.0)\nactivate_vertices!(dnet, collect(1:10), 0.0, 100.0)\nactivate!(dnet, 0.0, 50.0; edge=(1, 2))\nactivate!(dnet, 20.0, 80.0; edge=(2, 3))\nactivate!(dnet, 40.0, 100.0; edge=(3, 4))\n\n# Temporal centrality at time 50\ndeg = tDegree(dnet, 50.0)\nbet = tBetweenness(dnet, 50.0)\n\n# Temporal path finding\ndist = temporalDistance(dnet, 1, 4, 0.0)\npath = shortestTemporalPath(dnet, 1, 4, 0.0)\n\n# Duration metrics\nmean_dur = tEdgeDuration(dnet; aggregate=:mean)\nturnover = tTurnover(dnet, 20.0)","category":"section"},{"location":"index.html#Choosing-Analyses","page":"Home","title":"Choosing Analyses","text":"Question Function\nWho is most central at time t? tDegree, tBetweenness, tCloseness\nHow fast can information spread? temporalDistance, forwardReachableSet\nWho can reach whom? forwardReachableSet, backwardReachableSet\nHow stable are ties? tEdgeDuration, tEdgePersistence\nHow much turnover is there? tTurnover, tieDecay\nHow does the network evolve? tSnaStats, windowSnaStats","category":"section"},{"location":"index.html#Documentation","page":"Home","title":"Documentation","text":"Pages = [\n    \"getting_started.md\",\n    \"guide/centrality.md\",\n    \"guide/paths.md\",\n    \"guide/metrics.md\",\n    \"api/centrality.md\",\n    \"api/paths.md\",\n    \"api/metrics.md\",\n]\nDepth = 2","category":"section"},{"location":"index.html#Theoretical-Background","page":"Home","title":"Theoretical Background","text":"","category":"section"},{"location":"index.html#Time-Respecting-Paths","page":"Home","title":"Time-Respecting Paths","text":"In a temporal network, a valid path from s to r starting at time t_0 must traverse edges in non-decreasing time order:\n\ns = v_0 xrightarrowt_1 v_1 xrightarrowt_2 v_2 xrightarrowt_3 ldots xrightarrowt_k v_k = r\n\nWhere t_0 leq t_1 leq t_2 leq ldots leq t_k and each edge (v_i-1 v_i) is active at time t_i.\n\nThis constraint means that temporal reachability is not symmetric and not transitive in general.","category":"section"},{"location":"index.html#Temporal-Distance","page":"Home","title":"Temporal Distance","text":"The temporal distance from s to r starting at t_0 is the earliest time at which r can be reached:\n\nd_T(s r t_0) = mint_k  exists text time-respecting path  s to r text starting at  t_0 text arriving at  t_k","category":"section"},{"location":"index.html#References","page":"Home","title":"References","text":"Bender-deMoll, S., Morris, M. (2012). tsna: Tools for Temporal Social Network Analysis. R package.\nHolme, P. (2015). Modern temporal network theory: a colloquium. European Physical Journal B, 88(9), 1-30.\nHolme, P., Saramaki, J. (2012). Temporal networks. Physics Reports, 519(3), 97-125.\nNicosia, V., Tang, J., Mascolo, C., Musolesi, M., Russo, G., Latora, V. (2013). Graph metrics for temporal networks. In Temporal Networks (pp. 15-40). Springer.","category":"section"}]
}
